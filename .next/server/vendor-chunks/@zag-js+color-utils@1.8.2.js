"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@zag-js+color-utils@1.8.2";
exports.ids = ["vendor-chunks/@zag-js+color-utils@1.8.2"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@zag-js+color-utils@1.8.2/node_modules/@zag-js/color-utils/dist/index.mjs":
/*!******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@zag-js+color-utils@1.8.2/node_modules/@zag-js/color-utils/dist/index.mjs ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Color: () => (/* binding */ Color),\n/* harmony export */   getColorAreaGradient: () => (/* binding */ getColorAreaGradient),\n/* harmony export */   normalizeColor: () => (/* binding */ normalizeColor),\n/* harmony export */   parseColor: () => (/* binding */ parseColor)\n/* harmony export */ });\n/* harmony import */ var _zag_js_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zag-js/utils */ \"(ssr)/./node_modules/.pnpm/@zag-js+utils@1.8.2/node_modules/@zag-js/utils/dist/index.mjs\");\n\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, key + \"\" , value);\n\n// src/color-format-gradient.ts\nvar generateRGB_R = (orientation, dir, zValue) => {\n  const maskImage = `linear-gradient(to ${orientation[Number(!dir)]}, transparent, #000)`;\n  const result = {\n    areaStyles: {\n      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(${zValue},0,0),rgb(${zValue},255,0))`\n    },\n    areaGradientStyles: {\n      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(${zValue},0,255),rgb(${zValue},255,255))`,\n      WebkitMaskImage: maskImage,\n      maskImage\n    }\n  };\n  return result;\n};\nvar generateRGB_G = (orientation, dir, zValue) => {\n  const maskImage = `linear-gradient(to ${orientation[Number(!dir)]}, transparent, #000)`;\n  const result = {\n    areaStyles: {\n      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,${zValue},0),rgb(255,${zValue},0))`\n    },\n    areaGradientStyles: {\n      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,${zValue},255),rgb(255,${zValue},255))`,\n      WebkitMaskImage: maskImage,\n      maskImage\n    }\n  };\n  return result;\n};\nvar generateRGB_B = (orientation, dir, zValue) => {\n  const maskImage = `linear-gradient(to ${orientation[Number(!dir)]}, transparent, #000)`;\n  const result = {\n    areaStyles: {\n      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,0,${zValue}),rgb(255,0,${zValue}))`\n    },\n    areaGradientStyles: {\n      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,255,${zValue}),rgb(255,255,${zValue}))`,\n      WebkitMaskImage: maskImage,\n      maskImage\n    }\n  };\n  return result;\n};\nvar generateHSL_H = (orientation, dir, zValue) => {\n  const result = {\n    areaStyles: {},\n    areaGradientStyles: {\n      background: [\n        `linear-gradient(to ${orientation[Number(dir)]}, hsla(0,0%,0%,1) 0%, hsla(0,0%,0%,0) 50%, hsla(0,0%,100%,0) 50%, hsla(0,0%,100%,1) 100%)`,\n        `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,50%),hsla(0,0%,50%,0))`,\n        `hsl(${zValue}, 100%, 50%)`\n      ].join(\",\")\n    }\n  };\n  return result;\n};\nvar generateHSL_S = (orientation, dir, alphaValue) => {\n  const result = {\n    areaStyles: {},\n    areaGradientStyles: {\n      background: [\n        `linear-gradient(to ${orientation[Number(!dir)]}, hsla(0,0%,0%,${alphaValue}) 0%, hsla(0,0%,0%,0) 50%, hsla(0,0%,100%,0) 50%, hsla(0,0%,100%,${alphaValue}) 100%)`,\n        `linear-gradient(to ${orientation[Number(dir)]},hsla(0,100%,50%,${alphaValue}),hsla(60,100%,50%,${alphaValue}),hsla(120,100%,50%,${alphaValue}),hsla(180,100%,50%,${alphaValue}),hsla(240,100%,50%,${alphaValue}),hsla(300,100%,50%,${alphaValue}),hsla(359,100%,50%,${alphaValue}))`,\n        \"hsl(0, 0%, 50%)\"\n      ].join(\",\")\n    }\n  };\n  return result;\n};\nvar generateHSL_L = (orientation, dir, zValue) => {\n  const result = {\n    areaStyles: {},\n    areaGradientStyles: {\n      backgroundImage: [\n        `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,${zValue}%),hsla(0,0%,${zValue}%,0))`,\n        `linear-gradient(to ${orientation[Number(dir)]},hsl(0,100%,${zValue}%),hsl(60,100%,${zValue}%),hsl(120,100%,${zValue}%),hsl(180,100%,${zValue}%),hsl(240,100%,${zValue}%),hsl(300,100%,${zValue}%),hsl(360,100%,${zValue}%))`\n      ].join(\",\")\n    }\n  };\n  return result;\n};\nvar generateHSB_H = (orientation, dir, zValue) => {\n  const result = {\n    areaStyles: {},\n    areaGradientStyles: {\n      background: [\n        `linear-gradient(to ${orientation[Number(dir)]},hsl(0,0%,0%),hsla(0,0%,0%,0))`,\n        `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,100%),hsla(0,0%,100%,0))`,\n        `hsl(${zValue}, 100%, 50%)`\n      ].join(\",\")\n    }\n  };\n  return result;\n};\nvar generateHSB_S = (orientation, dir, alphaValue) => {\n  const result = {\n    areaStyles: {},\n    areaGradientStyles: {\n      background: [\n        `linear-gradient(to ${orientation[Number(!dir)]},hsla(0,0%,0%,${alphaValue}),hsla(0,0%,0%,0))`,\n        `linear-gradient(to ${orientation[Number(dir)]},hsla(0,100%,50%,${alphaValue}),hsla(60,100%,50%,${alphaValue}),hsla(120,100%,50%,${alphaValue}),hsla(180,100%,50%,${alphaValue}),hsla(240,100%,50%,${alphaValue}),hsla(300,100%,50%,${alphaValue}),hsla(359,100%,50%,${alphaValue}))`,\n        `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,0%),hsl(0,0%,100%))`\n      ].join(\",\")\n    }\n  };\n  return result;\n};\nvar generateHSB_B = (orientation, dir, alphaValue) => {\n  const result = {\n    areaStyles: {},\n    areaGradientStyles: {\n      background: [\n        `linear-gradient(to ${orientation[Number(!dir)]},hsla(0,0%,100%,${alphaValue}),hsla(0,0%,100%,0))`,\n        `linear-gradient(to ${orientation[Number(dir)]},hsla(0,100%,50%,${alphaValue}),hsla(60,100%,50%,${alphaValue}),hsla(120,100%,50%,${alphaValue}),hsla(180,100%,50%,${alphaValue}),hsla(240,100%,50%,${alphaValue}),hsla(300,100%,50%,${alphaValue}),hsla(359,100%,50%,${alphaValue}))`,\n        \"#000\"\n      ].join(\",\")\n    }\n  };\n  return result;\n};\n\n// src/area-gradient.ts\nfunction getColorAreaGradient(color, options) {\n  const { xChannel, yChannel, dir: dirProp = \"ltr\" } = options;\n  const { zChannel } = color.getColorAxes({ xChannel, yChannel });\n  const zValue = color.getChannelValue(zChannel);\n  const { minValue: zMin, maxValue: zMax } = color.getChannelRange(zChannel);\n  const orientation = [\"top\", dirProp === \"rtl\" ? \"left\" : \"right\"];\n  let dir = false;\n  let background = { areaStyles: {}, areaGradientStyles: {} };\n  let alphaValue = (zValue - zMin) / (zMax - zMin);\n  let isHSL = color.getFormat() === \"hsla\";\n  switch (zChannel) {\n    case \"red\": {\n      dir = xChannel === \"green\";\n      background = generateRGB_R(orientation, dir, zValue);\n      break;\n    }\n    case \"green\": {\n      dir = xChannel === \"red\";\n      background = generateRGB_G(orientation, dir, zValue);\n      break;\n    }\n    case \"blue\": {\n      dir = xChannel === \"red\";\n      background = generateRGB_B(orientation, dir, zValue);\n      break;\n    }\n    case \"hue\": {\n      dir = xChannel !== \"saturation\";\n      if (isHSL) {\n        background = generateHSL_H(orientation, dir, zValue);\n      } else {\n        background = generateHSB_H(orientation, dir, zValue);\n      }\n      break;\n    }\n    case \"saturation\": {\n      dir = xChannel === \"hue\";\n      if (isHSL) {\n        background = generateHSL_S(orientation, dir, alphaValue);\n      } else {\n        background = generateHSB_S(orientation, dir, alphaValue);\n      }\n      break;\n    }\n    case \"brightness\": {\n      dir = xChannel === \"hue\";\n      background = generateHSB_B(orientation, dir, alphaValue);\n      break;\n    }\n    case \"lightness\": {\n      dir = xChannel === \"hue\";\n      background = generateHSL_L(orientation, dir, zValue);\n      break;\n    }\n  }\n  return background;\n}\nvar isEqualObject = (a, b) => {\n  if (Object.keys(a).length !== Object.keys(b).length) return false;\n  for (let key in a) if (a[key] !== b[key]) return false;\n  return true;\n};\nvar Color = class {\n  toHexInt() {\n    return this.toFormat(\"rgba\").toHexInt();\n  }\n  getChannelValue(channel) {\n    if (channel in this) return this[channel];\n    throw new Error(\"Unsupported color channel: \" + channel);\n  }\n  getChannelValuePercent(channel, valueToCheck) {\n    const value = valueToCheck ?? this.getChannelValue(channel);\n    const { minValue, maxValue } = this.getChannelRange(channel);\n    return (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.getValuePercent)(value, minValue, maxValue);\n  }\n  getChannelPercentValue(channel, percentToCheck) {\n    const { minValue, maxValue, step } = this.getChannelRange(channel);\n    const percentValue = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.getPercentValue)(percentToCheck, minValue, maxValue, step);\n    return (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.snapValueToStep)(percentValue, minValue, maxValue, step);\n  }\n  withChannelValue(channel, value) {\n    const { minValue, maxValue } = this.getChannelRange(channel);\n    if (channel in this) {\n      let clone = this.clone();\n      clone[channel] = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.clampValue)(value, minValue, maxValue);\n      return clone;\n    }\n    throw new Error(\"Unsupported color channel: \" + channel);\n  }\n  getColorAxes(xyChannels) {\n    let { xChannel, yChannel } = xyChannels;\n    let xCh = xChannel || this.getChannels().find((c) => c !== yChannel);\n    let yCh = yChannel || this.getChannels().find((c) => c !== xCh);\n    let zCh = this.getChannels().find((c) => c !== xCh && c !== yCh);\n    return { xChannel: xCh, yChannel: yCh, zChannel: zCh };\n  }\n  incrementChannel(channel, stepSize) {\n    const { minValue, maxValue, step } = this.getChannelRange(channel);\n    const value = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.snapValueToStep)(\n      (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.clampValue)(this.getChannelValue(channel) + stepSize, minValue, maxValue),\n      minValue,\n      maxValue,\n      step\n    );\n    return this.withChannelValue(channel, value);\n  }\n  decrementChannel(channel, stepSize) {\n    return this.incrementChannel(channel, -stepSize);\n  }\n  isEqual(color) {\n    const isSame = isEqualObject(this.toJSON(), color.toJSON());\n    return isSame && this.getChannelValue(\"alpha\") === color.getChannelValue(\"alpha\");\n  }\n};\nvar _RGBColor = class _RGBColor extends Color {\n  constructor(red, green, blue, alpha) {\n    super();\n    this.red = red;\n    this.green = green;\n    this.blue = blue;\n    this.alpha = alpha;\n  }\n  static parse(value) {\n    let colors = [];\n    if (/^#[\\da-f]+$/i.test(value) && [4, 5, 7, 9].includes(value.length)) {\n      const values = (value.length < 6 ? value.replace(/[^#]/gi, \"$&$&\") : value).slice(1).split(\"\");\n      while (values.length > 0) {\n        colors.push(parseInt(values.splice(0, 2).join(\"\"), 16));\n      }\n      colors[3] = colors[3] !== void 0 ? colors[3] / 255 : void 0;\n    }\n    const match = value.match(/^rgba?\\((.*)\\)$/);\n    if (match?.[1]) {\n      colors = match[1].split(\",\").map((value2) => Number(value2.trim())).map((num, i) => (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.clampValue)(num, 0, i < 3 ? 255 : 1));\n    }\n    return colors.length < 3 ? void 0 : new _RGBColor(colors[0], colors[1], colors[2], colors[3] ?? 1);\n  }\n  toString(format) {\n    switch (format) {\n      case \"hex\":\n        return \"#\" + (this.red.toString(16).padStart(2, \"0\") + this.green.toString(16).padStart(2, \"0\") + this.blue.toString(16).padStart(2, \"0\")).toUpperCase();\n      case \"hexa\":\n        return \"#\" + (this.red.toString(16).padStart(2, \"0\") + this.green.toString(16).padStart(2, \"0\") + this.blue.toString(16).padStart(2, \"0\") + Math.round(this.alpha * 255).toString(16).padStart(2, \"0\")).toUpperCase();\n      case \"rgb\":\n        return `rgb(${this.red}, ${this.green}, ${this.blue})`;\n      case \"css\":\n      case \"rgba\":\n        return `rgba(${this.red}, ${this.green}, ${this.blue}, ${this.alpha})`;\n      case \"hsl\":\n        return this.toHSL().toString(\"hsl\");\n      case \"hsb\":\n        return this.toHSB().toString(\"hsb\");\n      default:\n        return this.toFormat(format).toString(format);\n    }\n  }\n  toFormat(format) {\n    switch (format) {\n      case \"rgba\":\n        return this;\n      case \"hsba\":\n        return this.toHSB();\n      case \"hsla\":\n        return this.toHSL();\n      default:\n        throw new Error(\"Unsupported color conversion: rgb -> \" + format);\n    }\n  }\n  toHexInt() {\n    return this.red << 16 | this.green << 8 | this.blue;\n  }\n  /**\n   * Converts an RGB color value to HSB.\n   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#From_RGB.\n   * @returns An HSBColor object.\n   */\n  toHSB() {\n    const red = this.red / 255;\n    const green = this.green / 255;\n    const blue = this.blue / 255;\n    const min = Math.min(red, green, blue);\n    const brightness = Math.max(red, green, blue);\n    const chroma = brightness - min;\n    const saturation = brightness === 0 ? 0 : chroma / brightness;\n    let hue = 0;\n    if (chroma !== 0) {\n      switch (brightness) {\n        case red:\n          hue = (green - blue) / chroma + (green < blue ? 6 : 0);\n          break;\n        case green:\n          hue = (blue - red) / chroma + 2;\n          break;\n        case blue:\n          hue = (red - green) / chroma + 4;\n          break;\n      }\n      hue /= 6;\n    }\n    return new HSBColor(\n      (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.toFixedNumber)(hue * 360, 2),\n      (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.toFixedNumber)(saturation * 100, 2),\n      (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.toFixedNumber)(brightness * 100, 2),\n      (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.toFixedNumber)(this.alpha, 2)\n    );\n  }\n  /**\n   * Converts an RGB color value to HSL.\n   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#From_RGB.\n   * @returns An HSLColor object.\n   */\n  toHSL() {\n    const red = this.red / 255;\n    const green = this.green / 255;\n    const blue = this.blue / 255;\n    const min = Math.min(red, green, blue);\n    const max = Math.max(red, green, blue);\n    const lightness = (max + min) / 2;\n    const chroma = max - min;\n    let hue = -1;\n    let saturation = -1;\n    if (chroma === 0) {\n      hue = saturation = 0;\n    } else {\n      saturation = chroma / (lightness < 0.5 ? max + min : 2 - max - min);\n      switch (max) {\n        case red:\n          hue = (green - blue) / chroma + (green < blue ? 6 : 0);\n          break;\n        case green:\n          hue = (blue - red) / chroma + 2;\n          break;\n        case blue:\n          hue = (red - green) / chroma + 4;\n          break;\n      }\n      hue /= 6;\n    }\n    return new HSLColor(\n      (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.toFixedNumber)(hue * 360, 2),\n      (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.toFixedNumber)(saturation * 100, 2),\n      (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.toFixedNumber)(lightness * 100, 2),\n      (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.toFixedNumber)(this.alpha, 2)\n    );\n  }\n  clone() {\n    return new _RGBColor(this.red, this.green, this.blue, this.alpha);\n  }\n  getChannelFormatOptions(channel) {\n    switch (channel) {\n      case \"red\":\n      case \"green\":\n      case \"blue\":\n        return { style: \"decimal\" };\n      case \"alpha\":\n        return { style: \"percent\" };\n      default:\n        throw new Error(\"Unknown color channel: \" + channel);\n    }\n  }\n  formatChannelValue(channel, locale) {\n    let options = this.getChannelFormatOptions(channel);\n    let value = this.getChannelValue(channel);\n    return new Intl.NumberFormat(locale, options).format(value);\n  }\n  getChannelRange(channel) {\n    switch (channel) {\n      case \"red\":\n      case \"green\":\n      case \"blue\":\n        return { minValue: 0, maxValue: 255, step: 1, pageSize: 17 };\n      case \"alpha\":\n        return { minValue: 0, maxValue: 1, step: 0.01, pageSize: 0.1 };\n      default:\n        throw new Error(\"Unknown color channel: \" + channel);\n    }\n  }\n  toJSON() {\n    return { r: this.red, g: this.green, b: this.blue, a: this.alpha };\n  }\n  getFormat() {\n    return \"rgba\";\n  }\n  getChannels() {\n    return _RGBColor.colorChannels;\n  }\n};\n__publicField(_RGBColor, \"colorChannels\", [\"red\", \"green\", \"blue\"]);\nvar RGBColor = _RGBColor;\n\n// src/hsl-color.ts\nvar HSL_REGEX = /hsl\\(([-+]?\\d+(?:.\\d+)?\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d+(?:.\\d+)?%)\\)|hsla\\(([-+]?\\d+(?:.\\d+)?\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d(.\\d+)?)\\)/;\nvar _HSLColor = class _HSLColor extends Color {\n  constructor(hue, saturation, lightness, alpha) {\n    super();\n    this.hue = hue;\n    this.saturation = saturation;\n    this.lightness = lightness;\n    this.alpha = alpha;\n  }\n  static parse(value) {\n    let m;\n    if (m = value.match(HSL_REGEX)) {\n      const [h, s, l, a] = (m[1] ?? m[2]).split(\",\").map((n) => Number(n.trim().replace(\"%\", \"\")));\n      return new _HSLColor((0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.mod)(h, 360), (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.clampValue)(s, 0, 100), (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.clampValue)(l, 0, 100), (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.clampValue)(a ?? 1, 0, 1));\n    }\n  }\n  toString(format) {\n    switch (format) {\n      case \"hex\":\n        return this.toRGB().toString(\"hex\");\n      case \"hexa\":\n        return this.toRGB().toString(\"hexa\");\n      case \"hsl\":\n        return `hsl(${this.hue}, ${(0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.toFixedNumber)(this.saturation, 2)}%, ${(0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.toFixedNumber)(this.lightness, 2)}%)`;\n      case \"css\":\n      case \"hsla\":\n        return `hsla(${this.hue}, ${(0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.toFixedNumber)(this.saturation, 2)}%, ${(0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.toFixedNumber)(this.lightness, 2)}%, ${this.alpha})`;\n      case \"hsb\":\n        return this.toHSB().toString(\"hsb\");\n      case \"rgb\":\n        return this.toRGB().toString(\"rgb\");\n      default:\n        return this.toFormat(format).toString(format);\n    }\n  }\n  toFormat(format) {\n    switch (format) {\n      case \"hsla\":\n        return this;\n      case \"hsba\":\n        return this.toHSB();\n      case \"rgba\":\n        return this.toRGB();\n      default:\n        throw new Error(\"Unsupported color conversion: hsl -> \" + format);\n    }\n  }\n  /**\n   * Converts a HSL color to HSB.\n   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSL_to_HSV.\n   * @returns An HSBColor object.\n   */\n  toHSB() {\n    let saturation = this.saturation / 100;\n    let lightness = this.lightness / 100;\n    let brightness = lightness + saturation * Math.min(lightness, 1 - lightness);\n    saturation = brightness === 0 ? 0 : 2 * (1 - lightness / brightness);\n    return new HSBColor(\n      (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.toFixedNumber)(this.hue, 2),\n      (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.toFixedNumber)(saturation * 100, 2),\n      (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.toFixedNumber)(brightness * 100, 2),\n      (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.toFixedNumber)(this.alpha, 2)\n    );\n  }\n  /**\n   * Converts a HSL color to RGB.\n   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSL_to_RGB_alternative.\n   * @returns An RGBColor object.\n   */\n  toRGB() {\n    let hue = this.hue;\n    let saturation = this.saturation / 100;\n    let lightness = this.lightness / 100;\n    let a = saturation * Math.min(lightness, 1 - lightness);\n    let fn = (n, k = (n + hue / 30) % 12) => lightness - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);\n    return new RGBColor(\n      Math.round(fn(0) * 255),\n      Math.round(fn(8) * 255),\n      Math.round(fn(4) * 255),\n      (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.toFixedNumber)(this.alpha, 2)\n    );\n  }\n  clone() {\n    return new _HSLColor(this.hue, this.saturation, this.lightness, this.alpha);\n  }\n  getChannelFormatOptions(channel) {\n    switch (channel) {\n      case \"hue\":\n        return { style: \"unit\", unit: \"degree\", unitDisplay: \"narrow\" };\n      case \"saturation\":\n      case \"lightness\":\n      case \"alpha\":\n        return { style: \"percent\" };\n      default:\n        throw new Error(\"Unknown color channel: \" + channel);\n    }\n  }\n  formatChannelValue(channel, locale) {\n    let options = this.getChannelFormatOptions(channel);\n    let value = this.getChannelValue(channel);\n    if (channel === \"saturation\" || channel === \"lightness\") {\n      value /= 100;\n    }\n    return new Intl.NumberFormat(locale, options).format(value);\n  }\n  getChannelRange(channel) {\n    switch (channel) {\n      case \"hue\":\n        return { minValue: 0, maxValue: 360, step: 1, pageSize: 15 };\n      case \"saturation\":\n      case \"lightness\":\n        return { minValue: 0, maxValue: 100, step: 1, pageSize: 10 };\n      case \"alpha\":\n        return { minValue: 0, maxValue: 1, step: 0.01, pageSize: 0.1 };\n      default:\n        throw new Error(\"Unknown color channel: \" + channel);\n    }\n  }\n  toJSON() {\n    return { h: this.hue, s: this.saturation, l: this.lightness, a: this.alpha };\n  }\n  getFormat() {\n    return \"hsla\";\n  }\n  getChannels() {\n    return _HSLColor.colorChannels;\n  }\n};\n__publicField(_HSLColor, \"colorChannels\", [\"hue\", \"saturation\", \"lightness\"]);\nvar HSLColor = _HSLColor;\n\n// src/hsb-color.ts\nvar HSB_REGEX = /hsb\\(([-+]?\\d+(?:.\\d+)?\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d+(?:.\\d+)?%)\\)|hsba\\(([-+]?\\d+(?:.\\d+)?\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d(.\\d+)?)\\)/;\nvar _HSBColor = class _HSBColor extends Color {\n  constructor(hue, saturation, brightness, alpha) {\n    super();\n    this.hue = hue;\n    this.saturation = saturation;\n    this.brightness = brightness;\n    this.alpha = alpha;\n  }\n  static parse(value) {\n    let m;\n    if (m = value.match(HSB_REGEX)) {\n      const [h, s, b, a] = (m[1] ?? m[2]).split(\",\").map((n) => Number(n.trim().replace(\"%\", \"\")));\n      return new _HSBColor((0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.mod)(h, 360), (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.clampValue)(s, 0, 100), (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.clampValue)(b, 0, 100), (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.clampValue)(a ?? 1, 0, 1));\n    }\n  }\n  toString(format) {\n    switch (format) {\n      case \"css\":\n        return this.toHSL().toString(\"css\");\n      case \"hex\":\n        return this.toRGB().toString(\"hex\");\n      case \"hexa\":\n        return this.toRGB().toString(\"hexa\");\n      case \"hsb\":\n        return `hsb(${this.hue}, ${(0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.toFixedNumber)(this.saturation, 2)}%, ${(0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.toFixedNumber)(this.brightness, 2)}%)`;\n      case \"hsba\":\n        return `hsba(${this.hue}, ${(0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.toFixedNumber)(this.saturation, 2)}%, ${(0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.toFixedNumber)(this.brightness, 2)}%, ${this.alpha})`;\n      case \"hsl\":\n        return this.toHSL().toString(\"hsl\");\n      case \"rgb\":\n        return this.toRGB().toString(\"rgb\");\n      default:\n        return this.toFormat(format).toString(format);\n    }\n  }\n  toFormat(format) {\n    switch (format) {\n      case \"hsba\":\n        return this;\n      case \"hsla\":\n        return this.toHSL();\n      case \"rgba\":\n        return this.toRGB();\n      default:\n        throw new Error(\"Unsupported color conversion: hsb -> \" + format);\n    }\n  }\n  /**\n   * Converts a HSB color to HSL.\n   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_HSL.\n   * @returns An HSLColor object.\n   */\n  toHSL() {\n    let saturation = this.saturation / 100;\n    let brightness = this.brightness / 100;\n    let lightness = brightness * (1 - saturation / 2);\n    saturation = lightness === 0 || lightness === 1 ? 0 : (brightness - lightness) / Math.min(lightness, 1 - lightness);\n    return new HSLColor(\n      (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.toFixedNumber)(this.hue, 2),\n      (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.toFixedNumber)(saturation * 100, 2),\n      (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.toFixedNumber)(lightness * 100, 2),\n      (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.toFixedNumber)(this.alpha, 2)\n    );\n  }\n  /**\n   * Converts a HSV color value to RGB.\n   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_RGB_alternative.\n   * @returns An RGBColor object.\n   */\n  toRGB() {\n    let hue = this.hue;\n    let saturation = this.saturation / 100;\n    let brightness = this.brightness / 100;\n    let fn = (n, k = (n + hue / 60) % 6) => brightness - saturation * brightness * Math.max(Math.min(k, 4 - k, 1), 0);\n    return new RGBColor(\n      Math.round(fn(5) * 255),\n      Math.round(fn(3) * 255),\n      Math.round(fn(1) * 255),\n      (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_0__.toFixedNumber)(this.alpha, 2)\n    );\n  }\n  clone() {\n    return new _HSBColor(this.hue, this.saturation, this.brightness, this.alpha);\n  }\n  getChannelFormatOptions(channel) {\n    switch (channel) {\n      case \"hue\":\n        return { style: \"unit\", unit: \"degree\", unitDisplay: \"narrow\" };\n      case \"saturation\":\n      case \"brightness\":\n      case \"alpha\":\n        return { style: \"percent\" };\n      default:\n        throw new Error(\"Unknown color channel: \" + channel);\n    }\n  }\n  formatChannelValue(channel, locale) {\n    let options = this.getChannelFormatOptions(channel);\n    let value = this.getChannelValue(channel);\n    if (channel === \"saturation\" || channel === \"brightness\") {\n      value /= 100;\n    }\n    return new Intl.NumberFormat(locale, options).format(value);\n  }\n  getChannelRange(channel) {\n    switch (channel) {\n      case \"hue\":\n        return { minValue: 0, maxValue: 360, step: 1, pageSize: 15 };\n      case \"saturation\":\n      case \"brightness\":\n        return { minValue: 0, maxValue: 100, step: 1, pageSize: 10 };\n      case \"alpha\":\n        return { minValue: 0, maxValue: 1, step: 0.01, pageSize: 0.1 };\n      default:\n        throw new Error(\"Unknown color channel: \" + channel);\n    }\n  }\n  toJSON() {\n    return { h: this.hue, s: this.saturation, b: this.brightness, a: this.alpha };\n  }\n  getFormat() {\n    return \"hsba\";\n  }\n  getChannels() {\n    return _HSBColor.colorChannels;\n  }\n};\n__publicField(_HSBColor, \"colorChannels\", [\"hue\", \"saturation\", \"brightness\"]);\nvar HSBColor = _HSBColor;\n\n// src/native-color.ts\nvar nativeColors = \"aliceblue:f0f8ff,antiquewhite:faebd7,aqua:00ffff,aquamarine:7fffd4,azure:f0ffff,beige:f5f5dc,bisque:ffe4c4,black:000000,blanchedalmond:ffebcd,blue:0000ff,blueviolet:8a2be2,brown:a52a2a,burlywood:deb887,cadetblue:5f9ea0,chartreuse:7fff00,chocolate:d2691e,coral:ff7f50,cornflowerblue:6495ed,cornsilk:fff8dc,crimson:dc143c,cyan:00ffff,darkblue:00008b,darkcyan:008b8b,darkgoldenrod:b8860b,darkgray:a9a9a9,darkgreen:006400,darkkhaki:bdb76b,darkmagenta:8b008b,darkolivegreen:556b2f,darkorange:ff8c00,darkorchid:9932cc,darkred:8b0000,darksalmon:e9967a,darkseagreen:8fbc8f,darkslateblue:483d8b,darkslategray:2f4f4f,darkturquoise:00ced1,darkviolet:9400d3,deeppink:ff1493,deepskyblue:00bfff,dimgray:696969,dodgerblue:1e90ff,firebrick:b22222,floralwhite:fffaf0,forestgreen:228b22,fuchsia:ff00ff,gainsboro:dcdcdc,ghostwhite:f8f8ff,gold:ffd700,goldenrod:daa520,gray:808080,green:008000,greenyellow:adff2f,honeydew:f0fff0,hotpink:ff69b4,indianred:cd5c5c,indigo:4b0082,ivory:fffff0,khaki:f0e68c,lavender:e6e6fa,lavenderblush:fff0f5,lawngreen:7cfc00,lemonchiffon:fffacd,lightblue:add8e6,lightcoral:f08080,lightcyan:e0ffff,lightgoldenrodyellow:fafad2,lightgrey:d3d3d3,lightgreen:90ee90,lightpink:ffb6c1,lightsalmon:ffa07a,lightseagreen:20b2aa,lightskyblue:87cefa,lightslategray:778899,lightsteelblue:b0c4de,lightyellow:ffffe0,lime:00ff00,limegreen:32cd32,linen:faf0e6,magenta:ff00ff,maroon:800000,mediumaquamarine:66cdaa,mediumblue:0000cd,mediumorchid:ba55d3,mediumpurple:9370d8,mediumseagreen:3cb371,mediumslateblue:7b68ee,mediumspringgreen:00fa9a,mediumturquoise:48d1cc,mediumvioletred:c71585,midnightblue:191970,mintcream:f5fffa,mistyrose:ffe4e1,moccasin:ffe4b5,navajowhite:ffdead,navy:000080,oldlace:fdf5e6,olive:808000,olivedrab:6b8e23,orange:ffa500,orangered:ff4500,orchid:da70d6,palegoldenrod:eee8aa,palegreen:98fb98,paleturquoise:afeeee,palevioletred:d87093,papayawhip:ffefd5,peachpuff:ffdab9,peru:cd853f,pink:ffc0cb,plum:dda0dd,powderblue:b0e0e6,purple:800080,rebeccapurple:663399,red:ff0000,rosybrown:bc8f8f,royalblue:4169e1,saddlebrown:8b4513,salmon:fa8072,sandybrown:f4a460,seagreen:2e8b57,seashell:fff5ee,sienna:a0522d,silver:c0c0c0,skyblue:87ceeb,slateblue:6a5acd,slategray:708090,snow:fffafa,springgreen:00ff7f,steelblue:4682b4,tan:d2b48c,teal:008080,thistle:d8bfd8,tomato:ff6347,turquoise:40e0d0,violet:ee82ee,wheat:f5deb3,white:ffffff,whitesmoke:f5f5f5,yellow:ffff00,yellowgreen:9acd32\";\nvar makeMap = (str) => {\n  const map = /* @__PURE__ */ new Map();\n  const list = str.split(\",\");\n  for (let i = 0; i < list.length; i++) {\n    const [key, val] = list[i].split(\":\");\n    map.set(key, `#${val}`);\n    if (key.includes(\"gray\")) map.set(key.replace(\"gray\", \"grey\"), `#${val}`);\n  }\n  return map;\n};\nvar nativeColorMap = makeMap(nativeColors);\n\n// src/parse-color.ts\nvar parseColor = (value) => {\n  if (nativeColorMap.has(value)) {\n    return parseColor(nativeColorMap.get(value));\n  }\n  const result = RGBColor.parse(value) || HSBColor.parse(value) || HSLColor.parse(value);\n  if (!result) {\n    const error = new Error(\"Invalid color value: \" + value);\n    Error.captureStackTrace?.(error, parseColor);\n    throw error;\n  }\n  return result;\n};\nvar normalizeColor = (v) => {\n  return typeof v === \"string\" ? parseColor(v) : v;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHphZy1qcytjb2xvci11dGlsc0AxLjguMi9ub2RlX21vZHVsZXMvQHphZy1qcy9jb2xvci11dGlscy9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFrSDs7QUFFbEg7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsMEJBQTBCO0FBQ3BFO0FBQ0E7QUFDQSw2Q0FBNkMseUJBQXlCLE9BQU8sT0FBTyxZQUFZLE9BQU87QUFDdkcsS0FBSztBQUNMO0FBQ0EsNkNBQTZDLHlCQUF5QixPQUFPLE9BQU8sY0FBYyxPQUFPO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDBCQUEwQjtBQUNwRTtBQUNBO0FBQ0EsNkNBQTZDLHlCQUF5QixTQUFTLE9BQU8sY0FBYyxPQUFPO0FBQzNHLEtBQUs7QUFDTDtBQUNBLDZDQUE2Qyx5QkFBeUIsU0FBUyxPQUFPLGdCQUFnQixPQUFPO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDBCQUEwQjtBQUNwRTtBQUNBO0FBQ0EsNkNBQTZDLHlCQUF5QixXQUFXLE9BQU8sY0FBYyxPQUFPO0FBQzdHLEtBQUs7QUFDTDtBQUNBLDZDQUE2Qyx5QkFBeUIsYUFBYSxPQUFPLGdCQUFnQixPQUFPO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLDhCQUE4Qix5QkFBeUI7QUFDdkQsOEJBQThCLDBCQUEwQjtBQUN4RCxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLDhCQUE4QiwwQkFBMEIsaUJBQWlCLFdBQVcsbUVBQW1FLFdBQVc7QUFDbEssOEJBQThCLHlCQUF5QixtQkFBbUIsV0FBVyxxQkFBcUIs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LGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBLHFCQUFxQixJQUFJO0FBQ3pCLHVFQUF1RSxJQUFJO0FBQzNFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVtRSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFx3ZXNqclxcRG9jdW1lbnRzXFxQcm9qZXRvc1xcZGFzaC1jcnlwdG9jb2luXFxub2RlX21vZHVsZXNcXC5wbnBtXFxAemFnLWpzK2NvbG9yLXV0aWxzQDEuOC4yXFxub2RlX21vZHVsZXNcXEB6YWctanNcXGNvbG9yLXV0aWxzXFxkaXN0XFxpbmRleC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0VmFsdWVQZXJjZW50LCBnZXRQZXJjZW50VmFsdWUsIHNuYXBWYWx1ZVRvU3RlcCwgY2xhbXBWYWx1ZSwgdG9GaXhlZE51bWJlciwgbW9kIH0gZnJvbSAnQHphZy1qcy91dGlscyc7XG5cbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IF9fZGVmTm9ybWFsUHJvcChvYmosIGtleSArIFwiXCIgLCB2YWx1ZSk7XG5cbi8vIHNyYy9jb2xvci1mb3JtYXQtZ3JhZGllbnQudHNcbnZhciBnZW5lcmF0ZVJHQl9SID0gKG9yaWVudGF0aW9uLCBkaXIsIHpWYWx1ZSkgPT4ge1xuICBjb25zdCBtYXNrSW1hZ2UgPSBgbGluZWFyLWdyYWRpZW50KHRvICR7b3JpZW50YXRpb25bTnVtYmVyKCFkaXIpXX0sIHRyYW5zcGFyZW50LCAjMDAwKWA7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBhcmVhU3R5bGVzOiB7XG4gICAgICBiYWNrZ3JvdW5kSW1hZ2U6IGBsaW5lYXItZ3JhZGllbnQodG8gJHtvcmllbnRhdGlvbltOdW1iZXIoZGlyKV19LHJnYigke3pWYWx1ZX0sMCwwKSxyZ2IoJHt6VmFsdWV9LDI1NSwwKSlgXG4gICAgfSxcbiAgICBhcmVhR3JhZGllbnRTdHlsZXM6IHtcbiAgICAgIGJhY2tncm91bmRJbWFnZTogYGxpbmVhci1ncmFkaWVudCh0byAke29yaWVudGF0aW9uW051bWJlcihkaXIpXX0scmdiKCR7elZhbHVlfSwwLDI1NSkscmdiKCR7elZhbHVlfSwyNTUsMjU1KSlgLFxuICAgICAgV2Via2l0TWFza0ltYWdlOiBtYXNrSW1hZ2UsXG4gICAgICBtYXNrSW1hZ2VcbiAgICB9XG4gIH07XG4gIHJldHVybiByZXN1bHQ7XG59O1xudmFyIGdlbmVyYXRlUkdCX0cgPSAob3JpZW50YXRpb24sIGRpciwgelZhbHVlKSA9PiB7XG4gIGNvbnN0IG1hc2tJbWFnZSA9IGBsaW5lYXItZ3JhZGllbnQodG8gJHtvcmllbnRhdGlvbltOdW1iZXIoIWRpcildfSwgdHJhbnNwYXJlbnQsICMwMDApYDtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIGFyZWFTdHlsZXM6IHtcbiAgICAgIGJhY2tncm91bmRJbWFnZTogYGxpbmVhci1ncmFkaWVudCh0byAke29yaWVudGF0aW9uW051bWJlcihkaXIpXX0scmdiKDAsJHt6VmFsdWV9LDApLHJnYigyNTUsJHt6VmFsdWV9LDApKWBcbiAgICB9LFxuICAgIGFyZWFHcmFkaWVudFN0eWxlczoge1xuICAgICAgYmFja2dyb3VuZEltYWdlOiBgbGluZWFyLWdyYWRpZW50KHRvICR7b3JpZW50YXRpb25bTnVtYmVyKGRpcildfSxyZ2IoMCwke3pWYWx1ZX0sMjU1KSxyZ2IoMjU1LCR7elZhbHVlfSwyNTUpKWAsXG4gICAgICBXZWJraXRNYXNrSW1hZ2U6IG1hc2tJbWFnZSxcbiAgICAgIG1hc2tJbWFnZVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgZ2VuZXJhdGVSR0JfQiA9IChvcmllbnRhdGlvbiwgZGlyLCB6VmFsdWUpID0+IHtcbiAgY29uc3QgbWFza0ltYWdlID0gYGxpbmVhci1ncmFkaWVudCh0byAke29yaWVudGF0aW9uW051bWJlcighZGlyKV19LCB0cmFuc3BhcmVudCwgIzAwMClgO1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgYXJlYVN0eWxlczoge1xuICAgICAgYmFja2dyb3VuZEltYWdlOiBgbGluZWFyLWdyYWRpZW50KHRvICR7b3JpZW50YXRpb25bTnVtYmVyKGRpcildfSxyZ2IoMCwwLCR7elZhbHVlfSkscmdiKDI1NSwwLCR7elZhbHVlfSkpYFxuICAgIH0sXG4gICAgYXJlYUdyYWRpZW50U3R5bGVzOiB7XG4gICAgICBiYWNrZ3JvdW5kSW1hZ2U6IGBsaW5lYXItZ3JhZGllbnQodG8gJHtvcmllbnRhdGlvbltOdW1iZXIoZGlyKV19LHJnYigwLDI1NSwke3pWYWx1ZX0pLHJnYigyNTUsMjU1LCR7elZhbHVlfSkpYCxcbiAgICAgIFdlYmtpdE1hc2tJbWFnZTogbWFza0ltYWdlLFxuICAgICAgbWFza0ltYWdlXG4gICAgfVxuICB9O1xuICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBnZW5lcmF0ZUhTTF9IID0gKG9yaWVudGF0aW9uLCBkaXIsIHpWYWx1ZSkgPT4ge1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgYXJlYVN0eWxlczoge30sXG4gICAgYXJlYUdyYWRpZW50U3R5bGVzOiB7XG4gICAgICBiYWNrZ3JvdW5kOiBbXG4gICAgICAgIGBsaW5lYXItZ3JhZGllbnQodG8gJHtvcmllbnRhdGlvbltOdW1iZXIoZGlyKV19LCBoc2xhKDAsMCUsMCUsMSkgMCUsIGhzbGEoMCwwJSwwJSwwKSA1MCUsIGhzbGEoMCwwJSwxMDAlLDApIDUwJSwgaHNsYSgwLDAlLDEwMCUsMSkgMTAwJSlgLFxuICAgICAgICBgbGluZWFyLWdyYWRpZW50KHRvICR7b3JpZW50YXRpb25bTnVtYmVyKCFkaXIpXX0saHNsKDAsMCUsNTAlKSxoc2xhKDAsMCUsNTAlLDApKWAsXG4gICAgICAgIGBoc2woJHt6VmFsdWV9LCAxMDAlLCA1MCUpYFxuICAgICAgXS5qb2luKFwiLFwiKVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgZ2VuZXJhdGVIU0xfUyA9IChvcmllbnRhdGlvbiwgZGlyLCBhbHBoYVZhbHVlKSA9PiB7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBhcmVhU3R5bGVzOiB7fSxcbiAgICBhcmVhR3JhZGllbnRTdHlsZXM6IHtcbiAgICAgIGJhY2tncm91bmQ6IFtcbiAgICAgICAgYGxpbmVhci1ncmFkaWVudCh0byAke29yaWVudGF0aW9uW051bWJlcighZGlyKV19LCBoc2xhKDAsMCUsMCUsJHthbHBoYVZhbHVlfSkgMCUsIGhzbGEoMCwwJSwwJSwwKSA1MCUsIGhzbGEoMCwwJSwxMDAlLDApIDUwJSwgaHNsYSgwLDAlLDEwMCUsJHthbHBoYVZhbHVlfSkgMTAwJSlgLFxuICAgICAgICBgbGluZWFyLWdyYWRpZW50KHRvICR7b3JpZW50YXRpb25bTnVtYmVyKGRpcildfSxoc2xhKDAsMTAwJSw1MCUsJHthbHBoYVZhbHVlfSksaHNsYSg2MCwxMDAlLDUwJSwke2FscGhhVmFsdWV9KSxoc2xhKDEyMCwxMDAlLDUwJSwke2FscGhhVmFsdWV9KSxoc2xhKDE4MCwxMDAlLDUwJSwke2FscGhhVmFsdWV9KSxoc2xhKDI0MCwxMDAlLDUwJSwke2FscGhhVmFsdWV9KSxoc2xhKDMwMCwxMDAlLDUwJSwke2FscGhhVmFsdWV9KSxoc2xhKDM1OSwxMDAlLDUwJSwke2FscGhhVmFsdWV9KSlgLFxuICAgICAgICBcImhzbCgwLCAwJSwgNTAlKVwiXG4gICAgICBdLmpvaW4oXCIsXCIpXG4gICAgfVxuICB9O1xuICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBnZW5lcmF0ZUhTTF9MID0gKG9yaWVudGF0aW9uLCBkaXIsIHpWYWx1ZSkgPT4ge1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgYXJlYVN0eWxlczoge30sXG4gICAgYXJlYUdyYWRpZW50U3R5bGVzOiB7XG4gICAgICBiYWNrZ3JvdW5kSW1hZ2U6IFtcbiAgICAgICAgYGxpbmVhci1ncmFkaWVudCh0byAke29yaWVudGF0aW9uW051bWJlcighZGlyKV19LGhzbCgwLDAlLCR7elZhbHVlfSUpLGhzbGEoMCwwJSwke3pWYWx1ZX0lLDApKWAsXG4gICAgICAgIGBsaW5lYXItZ3JhZGllbnQodG8gJHtvcmllbnRhdGlvbltOdW1iZXIoZGlyKV19LGhzbCgwLDEwMCUsJHt6VmFsdWV9JSksaHNsKDYwLDEwMCUsJHt6VmFsdWV9JSksaHNsKDEyMCwxMDAlLCR7elZhbHVlfSUpLGhzbCgxODAsMTAwJSwke3pWYWx1ZX0lKSxoc2woMjQwLDEwMCUsJHt6VmFsdWV9JSksaHNsKDMwMCwxMDAlLCR7elZhbHVlfSUpLGhzbCgzNjAsMTAwJSwke3pWYWx1ZX0lKSlgXG4gICAgICBdLmpvaW4oXCIsXCIpXG4gICAgfVxuICB9O1xuICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBnZW5lcmF0ZUhTQl9IID0gKG9yaWVudGF0aW9uLCBkaXIsIHpWYWx1ZSkgPT4ge1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgYXJlYVN0eWxlczoge30sXG4gICAgYXJlYUdyYWRpZW50U3R5bGVzOiB7XG4gICAgICBiYWNrZ3JvdW5kOiBbXG4gICAgICAgIGBsaW5lYXItZ3JhZGllbnQodG8gJHtvcmllbnRhdGlvbltOdW1iZXIoZGlyKV19LGhzbCgwLDAlLDAlKSxoc2xhKDAsMCUsMCUsMCkpYCxcbiAgICAgICAgYGxpbmVhci1ncmFkaWVudCh0byAke29yaWVudGF0aW9uW051bWJlcighZGlyKV19LGhzbCgwLDAlLDEwMCUpLGhzbGEoMCwwJSwxMDAlLDApKWAsXG4gICAgICAgIGBoc2woJHt6VmFsdWV9LCAxMDAlLCA1MCUpYFxuICAgICAgXS5qb2luKFwiLFwiKVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgZ2VuZXJhdGVIU0JfUyA9IChvcmllbnRhdGlvbiwgZGlyLCBhbHBoYVZhbHVlKSA9PiB7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBhcmVhU3R5bGVzOiB7fSxcbiAgICBhcmVhR3JhZGllbnRTdHlsZXM6IHtcbiAgICAgIGJhY2tncm91bmQ6IFtcbiAgICAgICAgYGxpbmVhci1ncmFkaWVudCh0byAke29yaWVudGF0aW9uW051bWJlcighZGlyKV19LGhzbGEoMCwwJSwwJSwke2FscGhhVmFsdWV9KSxoc2xhKDAsMCUsMCUsMCkpYCxcbiAgICAgICAgYGxpbmVhci1ncmFkaWVudCh0byAke29yaWVudGF0aW9uW051bWJlcihkaXIpXX0saHNsYSgwLDEwMCUsNTAlLCR7YWxwaGFWYWx1ZX0pLGhzbGEoNjAsMTAwJSw1MCUsJHthbHBoYVZhbHVlfSksaHNsYSgxMjAsMTAwJSw1MCUsJHthbHBoYVZhbHVlfSksaHNsYSgxODAsMTAwJSw1MCUsJHthbHBoYVZhbHVlfSksaHNsYSgyNDAsMTAwJSw1MCUsJHthbHBoYVZhbHVlfSksaHNsYSgzMDAsMTAwJSw1MCUsJHthbHBoYVZhbHVlfSksaHNsYSgzNTksMTAwJSw1MCUsJHthbHBoYVZhbHVlfSkpYCxcbiAgICAgICAgYGxpbmVhci1ncmFkaWVudCh0byAke29yaWVudGF0aW9uW051bWJlcighZGlyKV19LGhzbCgwLDAlLDAlKSxoc2woMCwwJSwxMDAlKSlgXG4gICAgICBdLmpvaW4oXCIsXCIpXG4gICAgfVxuICB9O1xuICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBnZW5lcmF0ZUhTQl9CID0gKG9yaWVudGF0aW9uLCBkaXIsIGFscGhhVmFsdWUpID0+IHtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIGFyZWFTdHlsZXM6IHt9LFxuICAgIGFyZWFHcmFkaWVudFN0eWxlczoge1xuICAgICAgYmFja2dyb3VuZDogW1xuICAgICAgICBgbGluZWFyLWdyYWRpZW50KHRvICR7b3JpZW50YXRpb25bTnVtYmVyKCFkaXIpXX0saHNsYSgwLDAlLDEwMCUsJHthbHBoYVZhbHVlfSksaHNsYSgwLDAlLDEwMCUsMCkpYCxcbiAgICAgICAgYGxpbmVhci1ncmFkaWVudCh0byAke29yaWVudGF0aW9uW051bWJlcihkaXIpXX0saHNsYSgwLDEwMCUsNTAlLCR7YWxwaGFWYWx1ZX0pLGhzbGEoNjAsMTAwJSw1MCUsJHthbHBoYVZhbHVlfSksaHNsYSgxMjAsMTAwJSw1MCUsJHthbHBoYVZhbHVlfSksaHNsYSgxODAsMTAwJSw1MCUsJHthbHBoYVZhbHVlfSksaHNsYSgyNDAsMTAwJSw1MCUsJHthbHBoYVZhbHVlfSksaHNsYSgzMDAsMTAwJSw1MCUsJHthbHBoYVZhbHVlfSksaHNsYSgzNTksMTAwJSw1MCUsJHthbHBoYVZhbHVlfSkpYCxcbiAgICAgICAgXCIjMDAwXCJcbiAgICAgIF0uam9pbihcIixcIilcbiAgICB9XG4gIH07XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyBzcmMvYXJlYS1ncmFkaWVudC50c1xuZnVuY3Rpb24gZ2V0Q29sb3JBcmVhR3JhZGllbnQoY29sb3IsIG9wdGlvbnMpIHtcbiAgY29uc3QgeyB4Q2hhbm5lbCwgeUNoYW5uZWwsIGRpcjogZGlyUHJvcCA9IFwibHRyXCIgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHsgekNoYW5uZWwgfSA9IGNvbG9yLmdldENvbG9yQXhlcyh7IHhDaGFubmVsLCB5Q2hhbm5lbCB9KTtcbiAgY29uc3QgelZhbHVlID0gY29sb3IuZ2V0Q2hhbm5lbFZhbHVlKHpDaGFubmVsKTtcbiAgY29uc3QgeyBtaW5WYWx1ZTogek1pbiwgbWF4VmFsdWU6IHpNYXggfSA9IGNvbG9yLmdldENoYW5uZWxSYW5nZSh6Q2hhbm5lbCk7XG4gIGNvbnN0IG9yaWVudGF0aW9uID0gW1widG9wXCIsIGRpclByb3AgPT09IFwicnRsXCIgPyBcImxlZnRcIiA6IFwicmlnaHRcIl07XG4gIGxldCBkaXIgPSBmYWxzZTtcbiAgbGV0IGJhY2tncm91bmQgPSB7IGFyZWFTdHlsZXM6IHt9LCBhcmVhR3JhZGllbnRTdHlsZXM6IHt9IH07XG4gIGxldCBhbHBoYVZhbHVlID0gKHpWYWx1ZSAtIHpNaW4pIC8gKHpNYXggLSB6TWluKTtcbiAgbGV0IGlzSFNMID0gY29sb3IuZ2V0Rm9ybWF0KCkgPT09IFwiaHNsYVwiO1xuICBzd2l0Y2ggKHpDaGFubmVsKSB7XG4gICAgY2FzZSBcInJlZFwiOiB7XG4gICAgICBkaXIgPSB4Q2hhbm5lbCA9PT0gXCJncmVlblwiO1xuICAgICAgYmFja2dyb3VuZCA9IGdlbmVyYXRlUkdCX1Iob3JpZW50YXRpb24sIGRpciwgelZhbHVlKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiZ3JlZW5cIjoge1xuICAgICAgZGlyID0geENoYW5uZWwgPT09IFwicmVkXCI7XG4gICAgICBiYWNrZ3JvdW5kID0gZ2VuZXJhdGVSR0JfRyhvcmllbnRhdGlvbiwgZGlyLCB6VmFsdWUpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJibHVlXCI6IHtcbiAgICAgIGRpciA9IHhDaGFubmVsID09PSBcInJlZFwiO1xuICAgICAgYmFja2dyb3VuZCA9IGdlbmVyYXRlUkdCX0Iob3JpZW50YXRpb24sIGRpciwgelZhbHVlKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiaHVlXCI6IHtcbiAgICAgIGRpciA9IHhDaGFubmVsICE9PSBcInNhdHVyYXRpb25cIjtcbiAgICAgIGlmIChpc0hTTCkge1xuICAgICAgICBiYWNrZ3JvdW5kID0gZ2VuZXJhdGVIU0xfSChvcmllbnRhdGlvbiwgZGlyLCB6VmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFja2dyb3VuZCA9IGdlbmVyYXRlSFNCX0gob3JpZW50YXRpb24sIGRpciwgelZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwic2F0dXJhdGlvblwiOiB7XG4gICAgICBkaXIgPSB4Q2hhbm5lbCA9PT0gXCJodWVcIjtcbiAgICAgIGlmIChpc0hTTCkge1xuICAgICAgICBiYWNrZ3JvdW5kID0gZ2VuZXJhdGVIU0xfUyhvcmllbnRhdGlvbiwgZGlyLCBhbHBoYVZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhY2tncm91bmQgPSBnZW5lcmF0ZUhTQl9TKG9yaWVudGF0aW9uLCBkaXIsIGFscGhhVmFsdWUpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJicmlnaHRuZXNzXCI6IHtcbiAgICAgIGRpciA9IHhDaGFubmVsID09PSBcImh1ZVwiO1xuICAgICAgYmFja2dyb3VuZCA9IGdlbmVyYXRlSFNCX0Iob3JpZW50YXRpb24sIGRpciwgYWxwaGFWYWx1ZSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImxpZ2h0bmVzc1wiOiB7XG4gICAgICBkaXIgPSB4Q2hhbm5lbCA9PT0gXCJodWVcIjtcbiAgICAgIGJhY2tncm91bmQgPSBnZW5lcmF0ZUhTTF9MKG9yaWVudGF0aW9uLCBkaXIsIHpWYWx1ZSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJhY2tncm91bmQ7XG59XG52YXIgaXNFcXVhbE9iamVjdCA9IChhLCBiKSA9PiB7XG4gIGlmIChPYmplY3Qua2V5cyhhKS5sZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICBmb3IgKGxldCBrZXkgaW4gYSkgaWYgKGFba2V5XSAhPT0gYltrZXldKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBDb2xvciA9IGNsYXNzIHtcbiAgdG9IZXhJbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9Gb3JtYXQoXCJyZ2JhXCIpLnRvSGV4SW50KCk7XG4gIH1cbiAgZ2V0Q2hhbm5lbFZhbHVlKGNoYW5uZWwpIHtcbiAgICBpZiAoY2hhbm5lbCBpbiB0aGlzKSByZXR1cm4gdGhpc1tjaGFubmVsXTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBjb2xvciBjaGFubmVsOiBcIiArIGNoYW5uZWwpO1xuICB9XG4gIGdldENoYW5uZWxWYWx1ZVBlcmNlbnQoY2hhbm5lbCwgdmFsdWVUb0NoZWNrKSB7XG4gICAgY29uc3QgdmFsdWUgPSB2YWx1ZVRvQ2hlY2sgPz8gdGhpcy5nZXRDaGFubmVsVmFsdWUoY2hhbm5lbCk7XG4gICAgY29uc3QgeyBtaW5WYWx1ZSwgbWF4VmFsdWUgfSA9IHRoaXMuZ2V0Q2hhbm5lbFJhbmdlKGNoYW5uZWwpO1xuICAgIHJldHVybiBnZXRWYWx1ZVBlcmNlbnQodmFsdWUsIG1pblZhbHVlLCBtYXhWYWx1ZSk7XG4gIH1cbiAgZ2V0Q2hhbm5lbFBlcmNlbnRWYWx1ZShjaGFubmVsLCBwZXJjZW50VG9DaGVjaykge1xuICAgIGNvbnN0IHsgbWluVmFsdWUsIG1heFZhbHVlLCBzdGVwIH0gPSB0aGlzLmdldENoYW5uZWxSYW5nZShjaGFubmVsKTtcbiAgICBjb25zdCBwZXJjZW50VmFsdWUgPSBnZXRQZXJjZW50VmFsdWUocGVyY2VudFRvQ2hlY2ssIG1pblZhbHVlLCBtYXhWYWx1ZSwgc3RlcCk7XG4gICAgcmV0dXJuIHNuYXBWYWx1ZVRvU3RlcChwZXJjZW50VmFsdWUsIG1pblZhbHVlLCBtYXhWYWx1ZSwgc3RlcCk7XG4gIH1cbiAgd2l0aENoYW5uZWxWYWx1ZShjaGFubmVsLCB2YWx1ZSkge1xuICAgIGNvbnN0IHsgbWluVmFsdWUsIG1heFZhbHVlIH0gPSB0aGlzLmdldENoYW5uZWxSYW5nZShjaGFubmVsKTtcbiAgICBpZiAoY2hhbm5lbCBpbiB0aGlzKSB7XG4gICAgICBsZXQgY2xvbmUgPSB0aGlzLmNsb25lKCk7XG4gICAgICBjbG9uZVtjaGFubmVsXSA9IGNsYW1wVmFsdWUodmFsdWUsIG1pblZhbHVlLCBtYXhWYWx1ZSk7XG4gICAgICByZXR1cm4gY2xvbmU7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGNvbG9yIGNoYW5uZWw6IFwiICsgY2hhbm5lbCk7XG4gIH1cbiAgZ2V0Q29sb3JBeGVzKHh5Q2hhbm5lbHMpIHtcbiAgICBsZXQgeyB4Q2hhbm5lbCwgeUNoYW5uZWwgfSA9IHh5Q2hhbm5lbHM7XG4gICAgbGV0IHhDaCA9IHhDaGFubmVsIHx8IHRoaXMuZ2V0Q2hhbm5lbHMoKS5maW5kKChjKSA9PiBjICE9PSB5Q2hhbm5lbCk7XG4gICAgbGV0IHlDaCA9IHlDaGFubmVsIHx8IHRoaXMuZ2V0Q2hhbm5lbHMoKS5maW5kKChjKSA9PiBjICE9PSB4Q2gpO1xuICAgIGxldCB6Q2ggPSB0aGlzLmdldENoYW5uZWxzKCkuZmluZCgoYykgPT4gYyAhPT0geENoICYmIGMgIT09IHlDaCk7XG4gICAgcmV0dXJuIHsgeENoYW5uZWw6IHhDaCwgeUNoYW5uZWw6IHlDaCwgekNoYW5uZWw6IHpDaCB9O1xuICB9XG4gIGluY3JlbWVudENoYW5uZWwoY2hhbm5lbCwgc3RlcFNpemUpIHtcbiAgICBjb25zdCB7IG1pblZhbHVlLCBtYXhWYWx1ZSwgc3RlcCB9ID0gdGhpcy5nZXRDaGFubmVsUmFuZ2UoY2hhbm5lbCk7XG4gICAgY29uc3QgdmFsdWUgPSBzbmFwVmFsdWVUb1N0ZXAoXG4gICAgICBjbGFtcFZhbHVlKHRoaXMuZ2V0Q2hhbm5lbFZhbHVlKGNoYW5uZWwpICsgc3RlcFNpemUsIG1pblZhbHVlLCBtYXhWYWx1ZSksXG4gICAgICBtaW5WYWx1ZSxcbiAgICAgIG1heFZhbHVlLFxuICAgICAgc3RlcFxuICAgICk7XG4gICAgcmV0dXJuIHRoaXMud2l0aENoYW5uZWxWYWx1ZShjaGFubmVsLCB2YWx1ZSk7XG4gIH1cbiAgZGVjcmVtZW50Q2hhbm5lbChjaGFubmVsLCBzdGVwU2l6ZSkge1xuICAgIHJldHVybiB0aGlzLmluY3JlbWVudENoYW5uZWwoY2hhbm5lbCwgLXN0ZXBTaXplKTtcbiAgfVxuICBpc0VxdWFsKGNvbG9yKSB7XG4gICAgY29uc3QgaXNTYW1lID0gaXNFcXVhbE9iamVjdCh0aGlzLnRvSlNPTigpLCBjb2xvci50b0pTT04oKSk7XG4gICAgcmV0dXJuIGlzU2FtZSAmJiB0aGlzLmdldENoYW5uZWxWYWx1ZShcImFscGhhXCIpID09PSBjb2xvci5nZXRDaGFubmVsVmFsdWUoXCJhbHBoYVwiKTtcbiAgfVxufTtcbnZhciBfUkdCQ29sb3IgPSBjbGFzcyBfUkdCQ29sb3IgZXh0ZW5kcyBDb2xvciB7XG4gIGNvbnN0cnVjdG9yKHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnJlZCA9IHJlZDtcbiAgICB0aGlzLmdyZWVuID0gZ3JlZW47XG4gICAgdGhpcy5ibHVlID0gYmx1ZTtcbiAgICB0aGlzLmFscGhhID0gYWxwaGE7XG4gIH1cbiAgc3RhdGljIHBhcnNlKHZhbHVlKSB7XG4gICAgbGV0IGNvbG9ycyA9IFtdO1xuICAgIGlmICgvXiNbXFxkYS1mXSskL2kudGVzdCh2YWx1ZSkgJiYgWzQsIDUsIDcsIDldLmluY2x1ZGVzKHZhbHVlLmxlbmd0aCkpIHtcbiAgICAgIGNvbnN0IHZhbHVlcyA9ICh2YWx1ZS5sZW5ndGggPCA2ID8gdmFsdWUucmVwbGFjZSgvW14jXS9naSwgXCIkJiQmXCIpIDogdmFsdWUpLnNsaWNlKDEpLnNwbGl0KFwiXCIpO1xuICAgICAgd2hpbGUgKHZhbHVlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbG9ycy5wdXNoKHBhcnNlSW50KHZhbHVlcy5zcGxpY2UoMCwgMikuam9pbihcIlwiKSwgMTYpKTtcbiAgICAgIH1cbiAgICAgIGNvbG9yc1szXSA9IGNvbG9yc1szXSAhPT0gdm9pZCAwID8gY29sb3JzWzNdIC8gMjU1IDogdm9pZCAwO1xuICAgIH1cbiAgICBjb25zdCBtYXRjaCA9IHZhbHVlLm1hdGNoKC9ecmdiYT9cXCgoLiopXFwpJC8pO1xuICAgIGlmIChtYXRjaD8uWzFdKSB7XG4gICAgICBjb2xvcnMgPSBtYXRjaFsxXS5zcGxpdChcIixcIikubWFwKCh2YWx1ZTIpID0+IE51bWJlcih2YWx1ZTIudHJpbSgpKSkubWFwKChudW0sIGkpID0+IGNsYW1wVmFsdWUobnVtLCAwLCBpIDwgMyA/IDI1NSA6IDEpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbG9ycy5sZW5ndGggPCAzID8gdm9pZCAwIDogbmV3IF9SR0JDb2xvcihjb2xvcnNbMF0sIGNvbG9yc1sxXSwgY29sb3JzWzJdLCBjb2xvcnNbM10gPz8gMSk7XG4gIH1cbiAgdG9TdHJpbmcoZm9ybWF0KSB7XG4gICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgIGNhc2UgXCJoZXhcIjpcbiAgICAgICAgcmV0dXJuIFwiI1wiICsgKHRoaXMucmVkLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIikgKyB0aGlzLmdyZWVuLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIikgKyB0aGlzLmJsdWUudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKSkudG9VcHBlckNhc2UoKTtcbiAgICAgIGNhc2UgXCJoZXhhXCI6XG4gICAgICAgIHJldHVybiBcIiNcIiArICh0aGlzLnJlZC50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpICsgdGhpcy5ncmVlbi50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpICsgdGhpcy5ibHVlLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIikgKyBNYXRoLnJvdW5kKHRoaXMuYWxwaGEgKiAyNTUpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIikpLnRvVXBwZXJDYXNlKCk7XG4gICAgICBjYXNlIFwicmdiXCI6XG4gICAgICAgIHJldHVybiBgcmdiKCR7dGhpcy5yZWR9LCAke3RoaXMuZ3JlZW59LCAke3RoaXMuYmx1ZX0pYDtcbiAgICAgIGNhc2UgXCJjc3NcIjpcbiAgICAgIGNhc2UgXCJyZ2JhXCI6XG4gICAgICAgIHJldHVybiBgcmdiYSgke3RoaXMucmVkfSwgJHt0aGlzLmdyZWVufSwgJHt0aGlzLmJsdWV9LCAke3RoaXMuYWxwaGF9KWA7XG4gICAgICBjYXNlIFwiaHNsXCI6XG4gICAgICAgIHJldHVybiB0aGlzLnRvSFNMKCkudG9TdHJpbmcoXCJoc2xcIik7XG4gICAgICBjYXNlIFwiaHNiXCI6XG4gICAgICAgIHJldHVybiB0aGlzLnRvSFNCKCkudG9TdHJpbmcoXCJoc2JcIik7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdGhpcy50b0Zvcm1hdChmb3JtYXQpLnRvU3RyaW5nKGZvcm1hdCk7XG4gICAgfVxuICB9XG4gIHRvRm9ybWF0KGZvcm1hdCkge1xuICAgIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgICBjYXNlIFwicmdiYVwiOlxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIGNhc2UgXCJoc2JhXCI6XG4gICAgICAgIHJldHVybiB0aGlzLnRvSFNCKCk7XG4gICAgICBjYXNlIFwiaHNsYVwiOlxuICAgICAgICByZXR1cm4gdGhpcy50b0hTTCgpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgY29sb3IgY29udmVyc2lvbjogcmdiIC0+IFwiICsgZm9ybWF0KTtcbiAgICB9XG4gIH1cbiAgdG9IZXhJbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVkIDw8IDE2IHwgdGhpcy5ncmVlbiA8PCA4IHwgdGhpcy5ibHVlO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhbiBSR0IgY29sb3IgdmFsdWUgdG8gSFNCLlxuICAgKiBDb252ZXJzaW9uIGZvcm11bGEgYWRhcHRlZCBmcm9tIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hTTF9hbmRfSFNWI0Zyb21fUkdCLlxuICAgKiBAcmV0dXJucyBBbiBIU0JDb2xvciBvYmplY3QuXG4gICAqL1xuICB0b0hTQigpIHtcbiAgICBjb25zdCByZWQgPSB0aGlzLnJlZCAvIDI1NTtcbiAgICBjb25zdCBncmVlbiA9IHRoaXMuZ3JlZW4gLyAyNTU7XG4gICAgY29uc3QgYmx1ZSA9IHRoaXMuYmx1ZSAvIDI1NTtcbiAgICBjb25zdCBtaW4gPSBNYXRoLm1pbihyZWQsIGdyZWVuLCBibHVlKTtcbiAgICBjb25zdCBicmlnaHRuZXNzID0gTWF0aC5tYXgocmVkLCBncmVlbiwgYmx1ZSk7XG4gICAgY29uc3QgY2hyb21hID0gYnJpZ2h0bmVzcyAtIG1pbjtcbiAgICBjb25zdCBzYXR1cmF0aW9uID0gYnJpZ2h0bmVzcyA9PT0gMCA/IDAgOiBjaHJvbWEgLyBicmlnaHRuZXNzO1xuICAgIGxldCBodWUgPSAwO1xuICAgIGlmIChjaHJvbWEgIT09IDApIHtcbiAgICAgIHN3aXRjaCAoYnJpZ2h0bmVzcykge1xuICAgICAgICBjYXNlIHJlZDpcbiAgICAgICAgICBodWUgPSAoZ3JlZW4gLSBibHVlKSAvIGNocm9tYSArIChncmVlbiA8IGJsdWUgPyA2IDogMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgZ3JlZW46XG4gICAgICAgICAgaHVlID0gKGJsdWUgLSByZWQpIC8gY2hyb21hICsgMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBibHVlOlxuICAgICAgICAgIGh1ZSA9IChyZWQgLSBncmVlbikgLyBjaHJvbWEgKyA0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaHVlIC89IDY7XG4gICAgfVxuICAgIHJldHVybiBuZXcgSFNCQ29sb3IoXG4gICAgICB0b0ZpeGVkTnVtYmVyKGh1ZSAqIDM2MCwgMiksXG4gICAgICB0b0ZpeGVkTnVtYmVyKHNhdHVyYXRpb24gKiAxMDAsIDIpLFxuICAgICAgdG9GaXhlZE51bWJlcihicmlnaHRuZXNzICogMTAwLCAyKSxcbiAgICAgIHRvRml4ZWROdW1iZXIodGhpcy5hbHBoYSwgMilcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhbiBSR0IgY29sb3IgdmFsdWUgdG8gSFNMLlxuICAgKiBDb252ZXJzaW9uIGZvcm11bGEgYWRhcHRlZCBmcm9tIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hTTF9hbmRfSFNWI0Zyb21fUkdCLlxuICAgKiBAcmV0dXJucyBBbiBIU0xDb2xvciBvYmplY3QuXG4gICAqL1xuICB0b0hTTCgpIHtcbiAgICBjb25zdCByZWQgPSB0aGlzLnJlZCAvIDI1NTtcbiAgICBjb25zdCBncmVlbiA9IHRoaXMuZ3JlZW4gLyAyNTU7XG4gICAgY29uc3QgYmx1ZSA9IHRoaXMuYmx1ZSAvIDI1NTtcbiAgICBjb25zdCBtaW4gPSBNYXRoLm1pbihyZWQsIGdyZWVuLCBibHVlKTtcbiAgICBjb25zdCBtYXggPSBNYXRoLm1heChyZWQsIGdyZWVuLCBibHVlKTtcbiAgICBjb25zdCBsaWdodG5lc3MgPSAobWF4ICsgbWluKSAvIDI7XG4gICAgY29uc3QgY2hyb21hID0gbWF4IC0gbWluO1xuICAgIGxldCBodWUgPSAtMTtcbiAgICBsZXQgc2F0dXJhdGlvbiA9IC0xO1xuICAgIGlmIChjaHJvbWEgPT09IDApIHtcbiAgICAgIGh1ZSA9IHNhdHVyYXRpb24gPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBzYXR1cmF0aW9uID0gY2hyb21hIC8gKGxpZ2h0bmVzcyA8IDAuNSA/IG1heCArIG1pbiA6IDIgLSBtYXggLSBtaW4pO1xuICAgICAgc3dpdGNoIChtYXgpIHtcbiAgICAgICAgY2FzZSByZWQ6XG4gICAgICAgICAgaHVlID0gKGdyZWVuIC0gYmx1ZSkgLyBjaHJvbWEgKyAoZ3JlZW4gPCBibHVlID8gNiA6IDApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGdyZWVuOlxuICAgICAgICAgIGh1ZSA9IChibHVlIC0gcmVkKSAvIGNocm9tYSArIDI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgYmx1ZTpcbiAgICAgICAgICBodWUgPSAocmVkIC0gZ3JlZW4pIC8gY2hyb21hICsgNDtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGh1ZSAvPSA2O1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEhTTENvbG9yKFxuICAgICAgdG9GaXhlZE51bWJlcihodWUgKiAzNjAsIDIpLFxuICAgICAgdG9GaXhlZE51bWJlcihzYXR1cmF0aW9uICogMTAwLCAyKSxcbiAgICAgIHRvRml4ZWROdW1iZXIobGlnaHRuZXNzICogMTAwLCAyKSxcbiAgICAgIHRvRml4ZWROdW1iZXIodGhpcy5hbHBoYSwgMilcbiAgICApO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgX1JHQkNvbG9yKHRoaXMucmVkLCB0aGlzLmdyZWVuLCB0aGlzLmJsdWUsIHRoaXMuYWxwaGEpO1xuICB9XG4gIGdldENoYW5uZWxGb3JtYXRPcHRpb25zKGNoYW5uZWwpIHtcbiAgICBzd2l0Y2ggKGNoYW5uZWwpIHtcbiAgICAgIGNhc2UgXCJyZWRcIjpcbiAgICAgIGNhc2UgXCJncmVlblwiOlxuICAgICAgY2FzZSBcImJsdWVcIjpcbiAgICAgICAgcmV0dXJuIHsgc3R5bGU6IFwiZGVjaW1hbFwiIH07XG4gICAgICBjYXNlIFwiYWxwaGFcIjpcbiAgICAgICAgcmV0dXJuIHsgc3R5bGU6IFwicGVyY2VudFwiIH07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGNvbG9yIGNoYW5uZWw6IFwiICsgY2hhbm5lbCk7XG4gICAgfVxuICB9XG4gIGZvcm1hdENoYW5uZWxWYWx1ZShjaGFubmVsLCBsb2NhbGUpIHtcbiAgICBsZXQgb3B0aW9ucyA9IHRoaXMuZ2V0Q2hhbm5lbEZvcm1hdE9wdGlvbnMoY2hhbm5lbCk7XG4gICAgbGV0IHZhbHVlID0gdGhpcy5nZXRDaGFubmVsVmFsdWUoY2hhbm5lbCk7XG4gICAgcmV0dXJuIG5ldyBJbnRsLk51bWJlckZvcm1hdChsb2NhbGUsIG9wdGlvbnMpLmZvcm1hdCh2YWx1ZSk7XG4gIH1cbiAgZ2V0Q2hhbm5lbFJhbmdlKGNoYW5uZWwpIHtcbiAgICBzd2l0Y2ggKGNoYW5uZWwpIHtcbiAgICAgIGNhc2UgXCJyZWRcIjpcbiAgICAgIGNhc2UgXCJncmVlblwiOlxuICAgICAgY2FzZSBcImJsdWVcIjpcbiAgICAgICAgcmV0dXJuIHsgbWluVmFsdWU6IDAsIG1heFZhbHVlOiAyNTUsIHN0ZXA6IDEsIHBhZ2VTaXplOiAxNyB9O1xuICAgICAgY2FzZSBcImFscGhhXCI6XG4gICAgICAgIHJldHVybiB7IG1pblZhbHVlOiAwLCBtYXhWYWx1ZTogMSwgc3RlcDogMC4wMSwgcGFnZVNpemU6IDAuMSB9O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBjb2xvciBjaGFubmVsOiBcIiArIGNoYW5uZWwpO1xuICAgIH1cbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHsgcjogdGhpcy5yZWQsIGc6IHRoaXMuZ3JlZW4sIGI6IHRoaXMuYmx1ZSwgYTogdGhpcy5hbHBoYSB9O1xuICB9XG4gIGdldEZvcm1hdCgpIHtcbiAgICByZXR1cm4gXCJyZ2JhXCI7XG4gIH1cbiAgZ2V0Q2hhbm5lbHMoKSB7XG4gICAgcmV0dXJuIF9SR0JDb2xvci5jb2xvckNoYW5uZWxzO1xuICB9XG59O1xuX19wdWJsaWNGaWVsZChfUkdCQ29sb3IsIFwiY29sb3JDaGFubmVsc1wiLCBbXCJyZWRcIiwgXCJncmVlblwiLCBcImJsdWVcIl0pO1xudmFyIFJHQkNvbG9yID0gX1JHQkNvbG9yO1xuXG4vLyBzcmMvaHNsLWNvbG9yLnRzXG52YXIgSFNMX1JFR0VYID0gL2hzbFxcKChbLStdP1xcZCsoPzouXFxkKyk/XFxzKixcXHMqWy0rXT9cXGQrKD86LlxcZCspPyVcXHMqLFxccypbLStdP1xcZCsoPzouXFxkKyk/JSlcXCl8aHNsYVxcKChbLStdP1xcZCsoPzouXFxkKyk/XFxzKixcXHMqWy0rXT9cXGQrKD86LlxcZCspPyVcXHMqLFxccypbLStdP1xcZCsoPzouXFxkKyk/JVxccyosXFxzKlstK10/XFxkKC5cXGQrKT8pXFwpLztcbnZhciBfSFNMQ29sb3IgPSBjbGFzcyBfSFNMQ29sb3IgZXh0ZW5kcyBDb2xvciB7XG4gIGNvbnN0cnVjdG9yKGh1ZSwgc2F0dXJhdGlvbiwgbGlnaHRuZXNzLCBhbHBoYSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5odWUgPSBodWU7XG4gICAgdGhpcy5zYXR1cmF0aW9uID0gc2F0dXJhdGlvbjtcbiAgICB0aGlzLmxpZ2h0bmVzcyA9IGxpZ2h0bmVzcztcbiAgICB0aGlzLmFscGhhID0gYWxwaGE7XG4gIH1cbiAgc3RhdGljIHBhcnNlKHZhbHVlKSB7XG4gICAgbGV0IG07XG4gICAgaWYgKG0gPSB2YWx1ZS5tYXRjaChIU0xfUkVHRVgpKSB7XG4gICAgICBjb25zdCBbaCwgcywgbCwgYV0gPSAobVsxXSA/PyBtWzJdKS5zcGxpdChcIixcIikubWFwKChuKSA9PiBOdW1iZXIobi50cmltKCkucmVwbGFjZShcIiVcIiwgXCJcIikpKTtcbiAgICAgIHJldHVybiBuZXcgX0hTTENvbG9yKG1vZChoLCAzNjApLCBjbGFtcFZhbHVlKHMsIDAsIDEwMCksIGNsYW1wVmFsdWUobCwgMCwgMTAwKSwgY2xhbXBWYWx1ZShhID8/IDEsIDAsIDEpKTtcbiAgICB9XG4gIH1cbiAgdG9TdHJpbmcoZm9ybWF0KSB7XG4gICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgIGNhc2UgXCJoZXhcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMudG9SR0IoKS50b1N0cmluZyhcImhleFwiKTtcbiAgICAgIGNhc2UgXCJoZXhhXCI6XG4gICAgICAgIHJldHVybiB0aGlzLnRvUkdCKCkudG9TdHJpbmcoXCJoZXhhXCIpO1xuICAgICAgY2FzZSBcImhzbFwiOlxuICAgICAgICByZXR1cm4gYGhzbCgke3RoaXMuaHVlfSwgJHt0b0ZpeGVkTnVtYmVyKHRoaXMuc2F0dXJhdGlvbiwgMil9JSwgJHt0b0ZpeGVkTnVtYmVyKHRoaXMubGlnaHRuZXNzLCAyKX0lKWA7XG4gICAgICBjYXNlIFwiY3NzXCI6XG4gICAgICBjYXNlIFwiaHNsYVwiOlxuICAgICAgICByZXR1cm4gYGhzbGEoJHt0aGlzLmh1ZX0sICR7dG9GaXhlZE51bWJlcih0aGlzLnNhdHVyYXRpb24sIDIpfSUsICR7dG9GaXhlZE51bWJlcih0aGlzLmxpZ2h0bmVzcywgMil9JSwgJHt0aGlzLmFscGhhfSlgO1xuICAgICAgY2FzZSBcImhzYlwiOlxuICAgICAgICByZXR1cm4gdGhpcy50b0hTQigpLnRvU3RyaW5nKFwiaHNiXCIpO1xuICAgICAgY2FzZSBcInJnYlwiOlxuICAgICAgICByZXR1cm4gdGhpcy50b1JHQigpLnRvU3RyaW5nKFwicmdiXCIpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXMudG9Gb3JtYXQoZm9ybWF0KS50b1N0cmluZyhmb3JtYXQpO1xuICAgIH1cbiAgfVxuICB0b0Zvcm1hdChmb3JtYXQpIHtcbiAgICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgICAgY2FzZSBcImhzbGFcIjpcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICBjYXNlIFwiaHNiYVwiOlxuICAgICAgICByZXR1cm4gdGhpcy50b0hTQigpO1xuICAgICAgY2FzZSBcInJnYmFcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMudG9SR0IoKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGNvbG9yIGNvbnZlcnNpb246IGhzbCAtPiBcIiArIGZvcm1hdCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIEhTTCBjb2xvciB0byBIU0IuXG4gICAqIENvbnZlcnNpb24gZm9ybXVsYSBhZGFwdGVkIGZyb20gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSFNMX2FuZF9IU1YjSFNMX3RvX0hTVi5cbiAgICogQHJldHVybnMgQW4gSFNCQ29sb3Igb2JqZWN0LlxuICAgKi9cbiAgdG9IU0IoKSB7XG4gICAgbGV0IHNhdHVyYXRpb24gPSB0aGlzLnNhdHVyYXRpb24gLyAxMDA7XG4gICAgbGV0IGxpZ2h0bmVzcyA9IHRoaXMubGlnaHRuZXNzIC8gMTAwO1xuICAgIGxldCBicmlnaHRuZXNzID0gbGlnaHRuZXNzICsgc2F0dXJhdGlvbiAqIE1hdGgubWluKGxpZ2h0bmVzcywgMSAtIGxpZ2h0bmVzcyk7XG4gICAgc2F0dXJhdGlvbiA9IGJyaWdodG5lc3MgPT09IDAgPyAwIDogMiAqICgxIC0gbGlnaHRuZXNzIC8gYnJpZ2h0bmVzcyk7XG4gICAgcmV0dXJuIG5ldyBIU0JDb2xvcihcbiAgICAgIHRvRml4ZWROdW1iZXIodGhpcy5odWUsIDIpLFxuICAgICAgdG9GaXhlZE51bWJlcihzYXR1cmF0aW9uICogMTAwLCAyKSxcbiAgICAgIHRvRml4ZWROdW1iZXIoYnJpZ2h0bmVzcyAqIDEwMCwgMiksXG4gICAgICB0b0ZpeGVkTnVtYmVyKHRoaXMuYWxwaGEsIDIpXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgYSBIU0wgY29sb3IgdG8gUkdCLlxuICAgKiBDb252ZXJzaW9uIGZvcm11bGEgYWRhcHRlZCBmcm9tIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hTTF9hbmRfSFNWI0hTTF90b19SR0JfYWx0ZXJuYXRpdmUuXG4gICAqIEByZXR1cm5zIEFuIFJHQkNvbG9yIG9iamVjdC5cbiAgICovXG4gIHRvUkdCKCkge1xuICAgIGxldCBodWUgPSB0aGlzLmh1ZTtcbiAgICBsZXQgc2F0dXJhdGlvbiA9IHRoaXMuc2F0dXJhdGlvbiAvIDEwMDtcbiAgICBsZXQgbGlnaHRuZXNzID0gdGhpcy5saWdodG5lc3MgLyAxMDA7XG4gICAgbGV0IGEgPSBzYXR1cmF0aW9uICogTWF0aC5taW4obGlnaHRuZXNzLCAxIC0gbGlnaHRuZXNzKTtcbiAgICBsZXQgZm4gPSAobiwgayA9IChuICsgaHVlIC8gMzApICUgMTIpID0+IGxpZ2h0bmVzcyAtIGEgKiBNYXRoLm1heChNYXRoLm1pbihrIC0gMywgOSAtIGssIDEpLCAtMSk7XG4gICAgcmV0dXJuIG5ldyBSR0JDb2xvcihcbiAgICAgIE1hdGgucm91bmQoZm4oMCkgKiAyNTUpLFxuICAgICAgTWF0aC5yb3VuZChmbig4KSAqIDI1NSksXG4gICAgICBNYXRoLnJvdW5kKGZuKDQpICogMjU1KSxcbiAgICAgIHRvRml4ZWROdW1iZXIodGhpcy5hbHBoYSwgMilcbiAgICApO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgX0hTTENvbG9yKHRoaXMuaHVlLCB0aGlzLnNhdHVyYXRpb24sIHRoaXMubGlnaHRuZXNzLCB0aGlzLmFscGhhKTtcbiAgfVxuICBnZXRDaGFubmVsRm9ybWF0T3B0aW9ucyhjaGFubmVsKSB7XG4gICAgc3dpdGNoIChjaGFubmVsKSB7XG4gICAgICBjYXNlIFwiaHVlXCI6XG4gICAgICAgIHJldHVybiB7IHN0eWxlOiBcInVuaXRcIiwgdW5pdDogXCJkZWdyZWVcIiwgdW5pdERpc3BsYXk6IFwibmFycm93XCIgfTtcbiAgICAgIGNhc2UgXCJzYXR1cmF0aW9uXCI6XG4gICAgICBjYXNlIFwibGlnaHRuZXNzXCI6XG4gICAgICBjYXNlIFwiYWxwaGFcIjpcbiAgICAgICAgcmV0dXJuIHsgc3R5bGU6IFwicGVyY2VudFwiIH07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGNvbG9yIGNoYW5uZWw6IFwiICsgY2hhbm5lbCk7XG4gICAgfVxuICB9XG4gIGZvcm1hdENoYW5uZWxWYWx1ZShjaGFubmVsLCBsb2NhbGUpIHtcbiAgICBsZXQgb3B0aW9ucyA9IHRoaXMuZ2V0Q2hhbm5lbEZvcm1hdE9wdGlvbnMoY2hhbm5lbCk7XG4gICAgbGV0IHZhbHVlID0gdGhpcy5nZXRDaGFubmVsVmFsdWUoY2hhbm5lbCk7XG4gICAgaWYgKGNoYW5uZWwgPT09IFwic2F0dXJhdGlvblwiIHx8IGNoYW5uZWwgPT09IFwibGlnaHRuZXNzXCIpIHtcbiAgICAgIHZhbHVlIC89IDEwMDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBJbnRsLk51bWJlckZvcm1hdChsb2NhbGUsIG9wdGlvbnMpLmZvcm1hdCh2YWx1ZSk7XG4gIH1cbiAgZ2V0Q2hhbm5lbFJhbmdlKGNoYW5uZWwpIHtcbiAgICBzd2l0Y2ggKGNoYW5uZWwpIHtcbiAgICAgIGNhc2UgXCJodWVcIjpcbiAgICAgICAgcmV0dXJuIHsgbWluVmFsdWU6IDAsIG1heFZhbHVlOiAzNjAsIHN0ZXA6IDEsIHBhZ2VTaXplOiAxNSB9O1xuICAgICAgY2FzZSBcInNhdHVyYXRpb25cIjpcbiAgICAgIGNhc2UgXCJsaWdodG5lc3NcIjpcbiAgICAgICAgcmV0dXJuIHsgbWluVmFsdWU6IDAsIG1heFZhbHVlOiAxMDAsIHN0ZXA6IDEsIHBhZ2VTaXplOiAxMCB9O1xuICAgICAgY2FzZSBcImFscGhhXCI6XG4gICAgICAgIHJldHVybiB7IG1pblZhbHVlOiAwLCBtYXhWYWx1ZTogMSwgc3RlcDogMC4wMSwgcGFnZVNpemU6IDAuMSB9O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBjb2xvciBjaGFubmVsOiBcIiArIGNoYW5uZWwpO1xuICAgIH1cbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHsgaDogdGhpcy5odWUsIHM6IHRoaXMuc2F0dXJhdGlvbiwgbDogdGhpcy5saWdodG5lc3MsIGE6IHRoaXMuYWxwaGEgfTtcbiAgfVxuICBnZXRGb3JtYXQoKSB7XG4gICAgcmV0dXJuIFwiaHNsYVwiO1xuICB9XG4gIGdldENoYW5uZWxzKCkge1xuICAgIHJldHVybiBfSFNMQ29sb3IuY29sb3JDaGFubmVscztcbiAgfVxufTtcbl9fcHVibGljRmllbGQoX0hTTENvbG9yLCBcImNvbG9yQ2hhbm5lbHNcIiwgW1wiaHVlXCIsIFwic2F0dXJhdGlvblwiLCBcImxpZ2h0bmVzc1wiXSk7XG52YXIgSFNMQ29sb3IgPSBfSFNMQ29sb3I7XG5cbi8vIHNyYy9oc2ItY29sb3IudHNcbnZhciBIU0JfUkVHRVggPSAvaHNiXFwoKFstK10/XFxkKyg/Oi5cXGQrKT9cXHMqLFxccypbLStdP1xcZCsoPzouXFxkKyk/JVxccyosXFxzKlstK10/XFxkKyg/Oi5cXGQrKT8lKVxcKXxoc2JhXFwoKFstK10/XFxkKyg/Oi5cXGQrKT9cXHMqLFxccypbLStdP1xcZCsoPzouXFxkKyk/JVxccyosXFxzKlstK10/XFxkKyg/Oi5cXGQrKT8lXFxzKixcXHMqWy0rXT9cXGQoLlxcZCspPylcXCkvO1xudmFyIF9IU0JDb2xvciA9IGNsYXNzIF9IU0JDb2xvciBleHRlbmRzIENvbG9yIHtcbiAgY29uc3RydWN0b3IoaHVlLCBzYXR1cmF0aW9uLCBicmlnaHRuZXNzLCBhbHBoYSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5odWUgPSBodWU7XG4gICAgdGhpcy5zYXR1cmF0aW9uID0gc2F0dXJhdGlvbjtcbiAgICB0aGlzLmJyaWdodG5lc3MgPSBicmlnaHRuZXNzO1xuICAgIHRoaXMuYWxwaGEgPSBhbHBoYTtcbiAgfVxuICBzdGF0aWMgcGFyc2UodmFsdWUpIHtcbiAgICBsZXQgbTtcbiAgICBpZiAobSA9IHZhbHVlLm1hdGNoKEhTQl9SRUdFWCkpIHtcbiAgICAgIGNvbnN0IFtoLCBzLCBiLCBhXSA9IChtWzFdID8/IG1bMl0pLnNwbGl0KFwiLFwiKS5tYXAoKG4pID0+IE51bWJlcihuLnRyaW0oKS5yZXBsYWNlKFwiJVwiLCBcIlwiKSkpO1xuICAgICAgcmV0dXJuIG5ldyBfSFNCQ29sb3IobW9kKGgsIDM2MCksIGNsYW1wVmFsdWUocywgMCwgMTAwKSwgY2xhbXBWYWx1ZShiLCAwLCAxMDApLCBjbGFtcFZhbHVlKGEgPz8gMSwgMCwgMSkpO1xuICAgIH1cbiAgfVxuICB0b1N0cmluZyhmb3JtYXQpIHtcbiAgICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgICAgY2FzZSBcImNzc1wiOlxuICAgICAgICByZXR1cm4gdGhpcy50b0hTTCgpLnRvU3RyaW5nKFwiY3NzXCIpO1xuICAgICAgY2FzZSBcImhleFwiOlxuICAgICAgICByZXR1cm4gdGhpcy50b1JHQigpLnRvU3RyaW5nKFwiaGV4XCIpO1xuICAgICAgY2FzZSBcImhleGFcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMudG9SR0IoKS50b1N0cmluZyhcImhleGFcIik7XG4gICAgICBjYXNlIFwiaHNiXCI6XG4gICAgICAgIHJldHVybiBgaHNiKCR7dGhpcy5odWV9LCAke3RvRml4ZWROdW1iZXIodGhpcy5zYXR1cmF0aW9uLCAyKX0lLCAke3RvRml4ZWROdW1iZXIodGhpcy5icmlnaHRuZXNzLCAyKX0lKWA7XG4gICAgICBjYXNlIFwiaHNiYVwiOlxuICAgICAgICByZXR1cm4gYGhzYmEoJHt0aGlzLmh1ZX0sICR7dG9GaXhlZE51bWJlcih0aGlzLnNhdHVyYXRpb24sIDIpfSUsICR7dG9GaXhlZE51bWJlcih0aGlzLmJyaWdodG5lc3MsIDIpfSUsICR7dGhpcy5hbHBoYX0pYDtcbiAgICAgIGNhc2UgXCJoc2xcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMudG9IU0woKS50b1N0cmluZyhcImhzbFwiKTtcbiAgICAgIGNhc2UgXCJyZ2JcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMudG9SR0IoKS50b1N0cmluZyhcInJnYlwiKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzLnRvRm9ybWF0KGZvcm1hdCkudG9TdHJpbmcoZm9ybWF0KTtcbiAgICB9XG4gIH1cbiAgdG9Gb3JtYXQoZm9ybWF0KSB7XG4gICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgIGNhc2UgXCJoc2JhXCI6XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgY2FzZSBcImhzbGFcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMudG9IU0woKTtcbiAgICAgIGNhc2UgXCJyZ2JhXCI6XG4gICAgICAgIHJldHVybiB0aGlzLnRvUkdCKCk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBjb2xvciBjb252ZXJzaW9uOiBoc2IgLT4gXCIgKyBmb3JtYXQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgYSBIU0IgY29sb3IgdG8gSFNMLlxuICAgKiBDb252ZXJzaW9uIGZvcm11bGEgYWRhcHRlZCBmcm9tIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hTTF9hbmRfSFNWI0hTVl90b19IU0wuXG4gICAqIEByZXR1cm5zIEFuIEhTTENvbG9yIG9iamVjdC5cbiAgICovXG4gIHRvSFNMKCkge1xuICAgIGxldCBzYXR1cmF0aW9uID0gdGhpcy5zYXR1cmF0aW9uIC8gMTAwO1xuICAgIGxldCBicmlnaHRuZXNzID0gdGhpcy5icmlnaHRuZXNzIC8gMTAwO1xuICAgIGxldCBsaWdodG5lc3MgPSBicmlnaHRuZXNzICogKDEgLSBzYXR1cmF0aW9uIC8gMik7XG4gICAgc2F0dXJhdGlvbiA9IGxpZ2h0bmVzcyA9PT0gMCB8fCBsaWdodG5lc3MgPT09IDEgPyAwIDogKGJyaWdodG5lc3MgLSBsaWdodG5lc3MpIC8gTWF0aC5taW4obGlnaHRuZXNzLCAxIC0gbGlnaHRuZXNzKTtcbiAgICByZXR1cm4gbmV3IEhTTENvbG9yKFxuICAgICAgdG9GaXhlZE51bWJlcih0aGlzLmh1ZSwgMiksXG4gICAgICB0b0ZpeGVkTnVtYmVyKHNhdHVyYXRpb24gKiAxMDAsIDIpLFxuICAgICAgdG9GaXhlZE51bWJlcihsaWdodG5lc3MgKiAxMDAsIDIpLFxuICAgICAgdG9GaXhlZE51bWJlcih0aGlzLmFscGhhLCAyKVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgSFNWIGNvbG9yIHZhbHVlIHRvIFJHQi5cbiAgICogQ29udmVyc2lvbiBmb3JtdWxhIGFkYXB0ZWQgZnJvbSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IU0xfYW5kX0hTViNIU1ZfdG9fUkdCX2FsdGVybmF0aXZlLlxuICAgKiBAcmV0dXJucyBBbiBSR0JDb2xvciBvYmplY3QuXG4gICAqL1xuICB0b1JHQigpIHtcbiAgICBsZXQgaHVlID0gdGhpcy5odWU7XG4gICAgbGV0IHNhdHVyYXRpb24gPSB0aGlzLnNhdHVyYXRpb24gLyAxMDA7XG4gICAgbGV0IGJyaWdodG5lc3MgPSB0aGlzLmJyaWdodG5lc3MgLyAxMDA7XG4gICAgbGV0IGZuID0gKG4sIGsgPSAobiArIGh1ZSAvIDYwKSAlIDYpID0+IGJyaWdodG5lc3MgLSBzYXR1cmF0aW9uICogYnJpZ2h0bmVzcyAqIE1hdGgubWF4KE1hdGgubWluKGssIDQgLSBrLCAxKSwgMCk7XG4gICAgcmV0dXJuIG5ldyBSR0JDb2xvcihcbiAgICAgIE1hdGgucm91bmQoZm4oNSkgKiAyNTUpLFxuICAgICAgTWF0aC5yb3VuZChmbigzKSAqIDI1NSksXG4gICAgICBNYXRoLnJvdW5kKGZuKDEpICogMjU1KSxcbiAgICAgIHRvRml4ZWROdW1iZXIodGhpcy5hbHBoYSwgMilcbiAgICApO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgX0hTQkNvbG9yKHRoaXMuaHVlLCB0aGlzLnNhdHVyYXRpb24sIHRoaXMuYnJpZ2h0bmVzcywgdGhpcy5hbHBoYSk7XG4gIH1cbiAgZ2V0Q2hhbm5lbEZvcm1hdE9wdGlvbnMoY2hhbm5lbCkge1xuICAgIHN3aXRjaCAoY2hhbm5lbCkge1xuICAgICAgY2FzZSBcImh1ZVwiOlxuICAgICAgICByZXR1cm4geyBzdHlsZTogXCJ1bml0XCIsIHVuaXQ6IFwiZGVncmVlXCIsIHVuaXREaXNwbGF5OiBcIm5hcnJvd1wiIH07XG4gICAgICBjYXNlIFwic2F0dXJhdGlvblwiOlxuICAgICAgY2FzZSBcImJyaWdodG5lc3NcIjpcbiAgICAgIGNhc2UgXCJhbHBoYVwiOlxuICAgICAgICByZXR1cm4geyBzdHlsZTogXCJwZXJjZW50XCIgfTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gY29sb3IgY2hhbm5lbDogXCIgKyBjaGFubmVsKTtcbiAgICB9XG4gIH1cbiAgZm9ybWF0Q2hhbm5lbFZhbHVlKGNoYW5uZWwsIGxvY2FsZSkge1xuICAgIGxldCBvcHRpb25zID0gdGhpcy5nZXRDaGFubmVsRm9ybWF0T3B0aW9ucyhjaGFubmVsKTtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLmdldENoYW5uZWxWYWx1ZShjaGFubmVsKTtcbiAgICBpZiAoY2hhbm5lbCA9PT0gXCJzYXR1cmF0aW9uXCIgfHwgY2hhbm5lbCA9PT0gXCJicmlnaHRuZXNzXCIpIHtcbiAgICAgIHZhbHVlIC89IDEwMDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBJbnRsLk51bWJlckZvcm1hdChsb2NhbGUsIG9wdGlvbnMpLmZvcm1hdCh2YWx1ZSk7XG4gIH1cbiAgZ2V0Q2hhbm5lbFJhbmdlKGNoYW5uZWwpIHtcbiAgICBzd2l0Y2ggKGNoYW5uZWwpIHtcbiAgICAgIGNhc2UgXCJodWVcIjpcbiAgICAgICAgcmV0dXJuIHsgbWluVmFsdWU6IDAsIG1heFZhbHVlOiAzNjAsIHN0ZXA6IDEsIHBhZ2VTaXplOiAxNSB9O1xuICAgICAgY2FzZSBcInNhdHVyYXRpb25cIjpcbiAgICAgIGNhc2UgXCJicmlnaHRuZXNzXCI6XG4gICAgICAgIHJldHVybiB7IG1pblZhbHVlOiAwLCBtYXhWYWx1ZTogMTAwLCBzdGVwOiAxLCBwYWdlU2l6ZTogMTAgfTtcbiAgICAgIGNhc2UgXCJhbHBoYVwiOlxuICAgICAgICByZXR1cm4geyBtaW5WYWx1ZTogMCwgbWF4VmFsdWU6IDEsIHN0ZXA6IDAuMDEsIHBhZ2VTaXplOiAwLjEgfTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gY29sb3IgY2hhbm5lbDogXCIgKyBjaGFubmVsKTtcbiAgICB9XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7IGg6IHRoaXMuaHVlLCBzOiB0aGlzLnNhdHVyYXRpb24sIGI6IHRoaXMuYnJpZ2h0bmVzcywgYTogdGhpcy5hbHBoYSB9O1xuICB9XG4gIGdldEZvcm1hdCgpIHtcbiAgICByZXR1cm4gXCJoc2JhXCI7XG4gIH1cbiAgZ2V0Q2hhbm5lbHMoKSB7XG4gICAgcmV0dXJuIF9IU0JDb2xvci5jb2xvckNoYW5uZWxzO1xuICB9XG59O1xuX19wdWJsaWNGaWVsZChfSFNCQ29sb3IsIFwiY29sb3JDaGFubmVsc1wiLCBbXCJodWVcIiwgXCJzYXR1cmF0aW9uXCIsIFwiYnJpZ2h0bmVzc1wiXSk7XG52YXIgSFNCQ29sb3IgPSBfSFNCQ29sb3I7XG5cbi8vIHNyYy9uYXRpdmUtY29sb3IudHNcbnZhciBuYXRpdmVDb2xvcnMgPSBcImFsaWNlYmx1ZTpmMGY4ZmYsYW50aXF1ZXdoaXRlOmZhZWJkNyxhcXVhOjAwZmZmZixhcXVhbWFyaW5lOjdmZmZkNCxhenVyZTpmMGZmZmYsYmVpZ2U6ZjVmNWRjLGJpc3F1ZTpmZmU0YzQsYmxhY2s6MDAwMDAwLGJsYW5jaGVkYWxtb25kOmZmZWJjZCxibHVlOjAwMDBmZixibHVldmlvbGV0OjhhMmJlMixicm93bjphNTJhMmEsYnVybHl3b29kOmRlYjg4NyxjYWRldGJsdWU6NWY5ZWEwLGNoYXJ0cmV1c2U6N2ZmZjAwLGNob2NvbGF0ZTpkMjY5MWUsY29yYWw6ZmY3ZjUwLGNvcm5mbG93ZXJibHVlOjY0OTVlZCxjb3Juc2lsazpmZmY4ZGMsY3JpbXNvbjpkYzE0M2MsY3lhbjowMGZmZmYsZGFya2JsdWU6MDAwMDhiLGRhcmtjeWFuOjAwOGI4YixkYXJrZ29sZGVucm9kOmI4ODYwYixkYXJrZ3JheTphOWE5YTksZGFya2dyZWVuOjAwNjQwMCxkYXJra2hha2k6YmRiNzZiLGRhcmttYWdlbnRhOjhiMDA4YixkYXJrb2xpdmVncmVlbjo1NTZiMmYsZGFya29yYW5nZTpmZjhjMDAsZGFya29yY2hpZDo5OTMyY2MsZGFya3JlZDo4YjAwMDAsZGFya3NhbG1vbjplOTk2N2EsZGFya3NlYWdyZWVuOjhmYmM4ZixkYXJrc2xhdGVibHVlOjQ4M2Q4YixkYXJrc2xhdGVncmF5OjJmNGY0ZixkYXJrdHVycXVvaXNlOjAwY2VkMSxkYXJrdmlvbGV0Ojk0MDBkMyxkZWVwcGluazpmZjE0OTMsZGVlcHNreWJsdWU6MDBiZmZmLGRpbWdyYXk6Njk2OTY5LGRvZGdlcmJsdWU6MWU5MGZmLGZpcmVicmljazpiMjIyMjIsZmxvcmFsd2hpdGU6ZmZmYWYwLGZvcmVzdGdyZWVuOjIyOGIyMixmdWNoc2lhOmZmMDBmZixnYWluc2Jvcm86ZGNkY2RjLGdob3N0d2hpdGU6ZjhmOGZmLGdvbGQ6ZmZkNzAwLGdvbGRlbnJvZDpkYWE1MjAsZ3JheTo4MDgwODAsZ3JlZW46MDA4MDAwLGdyZWVueWVsbG93OmFkZmYyZixob25leWRldzpmMGZmZjAsaG90cGluazpmZjY5YjQsaW5kaWFucmVkOmNkNWM1YyxpbmRpZ286NGIwMDgyLGl2b3J5OmZmZmZmMCxraGFraTpmMGU2OGMsbGF2ZW5kZXI6ZTZlNmZhLGxhdmVuZGVyYmx1c2g6ZmZmMGY1LGxhd25ncmVlbjo3Y2ZjMDAsbGVtb25jaGlmZm9uOmZmZmFjZCxsaWdodGJsdWU6YWRkOGU2LGxpZ2h0Y29yYWw6ZjA4MDgwLGxpZ2h0Y3lhbjplMGZmZmYsbGlnaHRnb2xkZW5yb2R5ZWxsb3c6ZmFmYWQyLGxpZ2h0Z3JleTpkM2QzZDMsbGlnaHRncmVlbjo5MGVlOTAsbGlnaHRwaW5rOmZmYjZjMSxsaWdodHNhbG1vbjpmZmEwN2EsbGlnaHRzZWFncmVlbjoyMGIyYWEsbGlnaHRza3libHVlOjg3Y2VmYSxsaWdodHNsYXRlZ3JheTo3Nzg4OTksbGlnaHRzdGVlbGJsdWU6YjBjNGRlLGxpZ2h0eWVsbG93OmZmZmZlMCxsaW1lOjAwZmYwMCxsaW1lZ3JlZW46MzJjZDMyLGxpbmVuOmZhZjBlNixtYWdlbnRhOmZmMDBmZixtYXJvb246ODAwMDAwLG1lZGl1bWFxdWFtYXJpbmU6NjZjZGFhLG1lZGl1bWJsdWU6MDAwMGNkLG1lZGl1bW9yY2hpZDpiYTU1ZDMsbWVkaXVtcHVycGxlOjkzNzBkOCxtZWRpdW1zZWFncmVlbjozY2IzNzEsbWVkaXVtc2xhdGVibHVlOjdiNjhlZSxtZWRpdW1zcHJpbmdncmVlbjowMGZhOWEsbWVkaXVtdHVycXVvaXNlOjQ4ZDFjYyxtZWRpdW12aW9sZXRyZWQ6YzcxNTg1LG1pZG5pZ2h0Ymx1ZToxOTE5NzAsbWludGNyZWFtOmY1ZmZmYSxtaXN0eXJvc2U6ZmZlNGUxLG1vY2Nhc2luOmZmZTRiNSxuYXZham93aGl0ZTpmZmRlYWQsbmF2eTowMDAwODAsb2xkbGFjZTpmZGY1ZTYsb2xpdmU6ODA4MDAwLG9saXZlZHJhYjo2YjhlMjMsb3JhbmdlOmZmYTUwMCxvcmFuZ2VyZWQ6ZmY0NTAwLG9yY2hpZDpkYTcwZDYscGFsZWdvbGRlbnJvZDplZWU4YWEscGFsZWdyZWVuOjk4ZmI5OCxwYWxldHVycXVvaXNlOmFmZWVlZSxwYWxldmlvbGV0cmVkOmQ4NzA5MyxwYXBheWF3aGlwOmZmZWZkNSxwZWFjaHB1ZmY6ZmZkYWI5LHBlcnU6Y2Q4NTNmLHBpbms6ZmZjMGNiLHBsdW06ZGRhMGRkLHBvd2RlcmJsdWU6YjBlMGU2LHB1cnBsZTo4MDAwODAscmViZWNjYXB1cnBsZTo2NjMzOTkscmVkOmZmMDAwMCxyb3N5YnJvd246YmM4ZjhmLHJveWFsYmx1ZTo0MTY5ZTEsc2FkZGxlYnJvd246OGI0NTEzLHNhbG1vbjpmYTgwNzIsc2FuZHlicm93bjpmNGE0NjAsc2VhZ3JlZW46MmU4YjU3LHNlYXNoZWxsOmZmZjVlZSxzaWVubmE6YTA1MjJkLHNpbHZlcjpjMGMwYzAsc2t5Ymx1ZTo4N2NlZWIsc2xhdGVibHVlOjZhNWFjZCxzbGF0ZWdyYXk6NzA4MDkwLHNub3c6ZmZmYWZhLHNwcmluZ2dyZWVuOjAwZmY3ZixzdGVlbGJsdWU6NDY4MmI0LHRhbjpkMmI0OGMsdGVhbDowMDgwODAsdGhpc3RsZTpkOGJmZDgsdG9tYXRvOmZmNjM0Nyx0dXJxdW9pc2U6NDBlMGQwLHZpb2xldDplZTgyZWUsd2hlYXQ6ZjVkZWIzLHdoaXRlOmZmZmZmZix3aGl0ZXNtb2tlOmY1ZjVmNSx5ZWxsb3c6ZmZmZjAwLHllbGxvd2dyZWVuOjlhY2QzMlwiO1xudmFyIG1ha2VNYXAgPSAoc3RyKSA9PiB7XG4gIGNvbnN0IG1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IGxpc3QgPSBzdHIuc3BsaXQoXCIsXCIpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBba2V5LCB2YWxdID0gbGlzdFtpXS5zcGxpdChcIjpcIik7XG4gICAgbWFwLnNldChrZXksIGAjJHt2YWx9YCk7XG4gICAgaWYgKGtleS5pbmNsdWRlcyhcImdyYXlcIikpIG1hcC5zZXQoa2V5LnJlcGxhY2UoXCJncmF5XCIsIFwiZ3JleVwiKSwgYCMke3ZhbH1gKTtcbiAgfVxuICByZXR1cm4gbWFwO1xufTtcbnZhciBuYXRpdmVDb2xvck1hcCA9IG1ha2VNYXAobmF0aXZlQ29sb3JzKTtcblxuLy8gc3JjL3BhcnNlLWNvbG9yLnRzXG52YXIgcGFyc2VDb2xvciA9ICh2YWx1ZSkgPT4ge1xuICBpZiAobmF0aXZlQ29sb3JNYXAuaGFzKHZhbHVlKSkge1xuICAgIHJldHVybiBwYXJzZUNvbG9yKG5hdGl2ZUNvbG9yTWFwLmdldCh2YWx1ZSkpO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IFJHQkNvbG9yLnBhcnNlKHZhbHVlKSB8fCBIU0JDb2xvci5wYXJzZSh2YWx1ZSkgfHwgSFNMQ29sb3IucGFyc2UodmFsdWUpO1xuICBpZiAoIXJlc3VsdCkge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFwiSW52YWxpZCBjb2xvciB2YWx1ZTogXCIgKyB2YWx1ZSk7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2U/LihlcnJvciwgcGFyc2VDb2xvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgbm9ybWFsaXplQ29sb3IgPSAodikgPT4ge1xuICByZXR1cm4gdHlwZW9mIHYgPT09IFwic3RyaW5nXCIgPyBwYXJzZUNvbG9yKHYpIDogdjtcbn07XG5cbmV4cG9ydCB7IENvbG9yLCBnZXRDb2xvckFyZWFHcmFkaWVudCwgbm9ybWFsaXplQ29sb3IsIHBhcnNlQ29sb3IgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@zag-js+color-utils@1.8.2/node_modules/@zag-js/color-utils/dist/index.mjs\n");

/***/ })

};
;