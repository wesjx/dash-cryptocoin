"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@zag-js+store@1.8.2";
exports.ids = ["vendor-chunks/@zag-js+store@1.8.2"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@zag-js+store@1.8.2/node_modules/@zag-js/store/dist/index.mjs":
/*!******************************************************************************************!*\
  !*** ./node_modules/.pnpm/@zag-js+store@1.8.2/node_modules/@zag-js/store/dist/index.mjs ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clone: () => (/* binding */ clone),\n/* harmony export */   globalRef: () => (/* binding */ globalRef),\n/* harmony export */   proxy: () => (/* binding */ proxy),\n/* harmony export */   proxyWithComputed: () => (/* binding */ proxyWithComputed),\n/* harmony export */   ref: () => (/* binding */ ref),\n/* harmony export */   snapshot: () => (/* binding */ snapshot),\n/* harmony export */   subscribe: () => (/* binding */ subscribe)\n/* harmony export */ });\n/* harmony import */ var proxy_compare__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! proxy-compare */ \"(ssr)/./node_modules/.pnpm/proxy-compare@3.0.1/node_modules/proxy-compare/dist/index.js\");\n\n\n// src/global.ts\nfunction glob() {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n}\nfunction globalRef(key, value) {\n  const g = glob();\n  if (!g) return value();\n  g[key] || (g[key] = value());\n  return g[key];\n}\nvar refSet = globalRef(\"__zag__refSet\", () => /* @__PURE__ */ new WeakSet());\n\n// src/utils.ts\nvar isReactElement = (x) => typeof x === \"object\" && x !== null && \"$$typeof\" in x && \"props\" in x;\nvar isVueElement = (x) => typeof x === \"object\" && x !== null && \"__v_isVNode\" in x;\nvar isDOMElement = (x) => typeof x === \"object\" && x !== null && \"nodeType\" in x && typeof x.nodeName === \"string\";\nvar isElement = (x) => isReactElement(x) || isVueElement(x) || isDOMElement(x);\nvar isObject = (x) => x !== null && typeof x === \"object\";\nvar canProxy = (x) => isObject(x) && !refSet.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !isElement(x) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer) && !(x instanceof Promise);\nvar isDev = () => \"development\" !== \"production\";\n\n// src/clone.ts\nfunction set(obj, key, val) {\n  if (typeof val.value === \"object\" && !canProxy(val.value)) val.value = clone(val.value);\n  if (!val.enumerable || val.get || val.set || !val.configurable || !val.writable || key === \"__proto__\") {\n    Object.defineProperty(obj, key, val);\n  } else obj[key] = val.value;\n}\nfunction clone(x) {\n  if (typeof x !== \"object\") return x;\n  var i = 0, k, list, tmp, str = Object.prototype.toString.call(x);\n  if (str === \"[object Object]\") {\n    tmp = Object.create(Object.getPrototypeOf(x) || null);\n  } else if (str === \"[object Array]\") {\n    tmp = Array(x.length);\n  } else if (str === \"[object Set]\") {\n    tmp = /* @__PURE__ */ new Set();\n    x.forEach(function(val) {\n      tmp.add(clone(val));\n    });\n  } else if (str === \"[object Map]\") {\n    tmp = /* @__PURE__ */ new Map();\n    x.forEach(function(val, key) {\n      tmp.set(clone(key), clone(val));\n    });\n  } else if (str === \"[object Date]\") {\n    tmp = /* @__PURE__ */ new Date(+x);\n  } else if (str === \"[object RegExp]\") {\n    tmp = new RegExp(x.source, x.flags);\n  } else if (str === \"[object DataView]\") {\n    tmp = new x.constructor(clone(x.buffer));\n  } else if (str === \"[object ArrayBuffer]\") {\n    tmp = x.slice(0);\n  } else if (str === \"[object Blob]\") {\n    tmp = x.slice();\n  } else if (str.slice(-6) === \"Array]\") {\n    tmp = new x.constructor(x);\n  }\n  if (tmp) {\n    for (list = Object.getOwnPropertySymbols(x); i < list.length; i++) {\n      set(tmp, list[i], Object.getOwnPropertyDescriptor(x, list[i]));\n    }\n    for (i = 0, list = Object.getOwnPropertyNames(x); i < list.length; i++) {\n      if (Object.hasOwnProperty.call(tmp, k = list[i]) && tmp[k] === x[k]) continue;\n      set(tmp, k, Object.getOwnPropertyDescriptor(x, k));\n    }\n  }\n  return tmp || x;\n}\nvar proxyStateMap = globalRef(\"__zag__proxyStateMap\", () => /* @__PURE__ */ new WeakMap());\nvar buildProxyFunction = (objectIs = Object.is, newProxy = (target, handler) => new Proxy(target, handler), snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version) => {\n  const cache = snapCache.get(target);\n  if (cache?.[0] === version) {\n    return cache[1];\n  }\n  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));\n  (0,proxy_compare__WEBPACK_IMPORTED_MODULE_0__.markToTrack)(snap, true);\n  snapCache.set(target, [version, snap]);\n  Reflect.ownKeys(target).forEach((key) => {\n    const value = Reflect.get(target, key);\n    if (refSet.has(value)) {\n      (0,proxy_compare__WEBPACK_IMPORTED_MODULE_0__.markToTrack)(value, false);\n      snap[key] = value;\n    } else if (proxyStateMap.has(value)) {\n      snap[key] = snapshot(value);\n    } else {\n      snap[key] = value;\n    }\n  });\n  return Object.freeze(snap);\n}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction2 = (initialObject) => {\n  if (!isObject(initialObject)) {\n    throw new Error(\"object required\");\n  }\n  const found = proxyCache.get(initialObject);\n  if (found) {\n    return found;\n  }\n  let version = versionHolder[0];\n  const listeners = /* @__PURE__ */ new Set();\n  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {\n    if (version !== nextVersion) {\n      version = nextVersion;\n      listeners.forEach((listener) => listener(op, nextVersion));\n    }\n  };\n  let checkVersion = versionHolder[1];\n  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {\n    if (checkVersion !== nextCheckVersion && !listeners.size) {\n      checkVersion = nextCheckVersion;\n      propProxyStates.forEach(([propProxyState]) => {\n        const propVersion = propProxyState[1](nextCheckVersion);\n        if (propVersion > version) {\n          version = propVersion;\n        }\n      });\n    }\n    return version;\n  };\n  const createPropListener = (prop) => (op, nextVersion) => {\n    const newOp = [...op];\n    newOp[1] = [prop, ...newOp[1]];\n    notifyUpdate(newOp, nextVersion);\n  };\n  const propProxyStates = /* @__PURE__ */ new Map();\n  const addPropListener = (prop, propProxyState) => {\n    if (isDev() && propProxyStates.has(prop)) {\n      throw new Error(\"prop listener already exists\");\n    }\n    if (listeners.size) {\n      const remove = propProxyState[3](createPropListener(prop));\n      propProxyStates.set(prop, [propProxyState, remove]);\n    } else {\n      propProxyStates.set(prop, [propProxyState]);\n    }\n  };\n  const removePropListener = (prop) => {\n    const entry = propProxyStates.get(prop);\n    if (entry) {\n      propProxyStates.delete(prop);\n      entry[1]?.();\n    }\n  };\n  const addListener = (listener) => {\n    listeners.add(listener);\n    if (listeners.size === 1) {\n      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {\n        if (isDev() && prevRemove) {\n          throw new Error(\"remove already exists\");\n        }\n        const remove = propProxyState[3](createPropListener(prop));\n        propProxyStates.set(prop, [propProxyState, remove]);\n      });\n    }\n    const removeListener = () => {\n      listeners.delete(listener);\n      if (listeners.size === 0) {\n        propProxyStates.forEach(([propProxyState, remove], prop) => {\n          if (remove) {\n            remove();\n            propProxyStates.set(prop, [propProxyState]);\n          }\n        });\n      }\n    };\n    return removeListener;\n  };\n  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));\n  const handler = {\n    deleteProperty(target, prop) {\n      const prevValue = Reflect.get(target, prop);\n      removePropListener(prop);\n      const deleted = Reflect.deleteProperty(target, prop);\n      if (deleted) {\n        notifyUpdate([\"delete\", [prop], prevValue]);\n      }\n      return deleted;\n    },\n    set(target, prop, value, receiver) {\n      const hasPrevValue = Reflect.has(target, prop);\n      const prevValue = Reflect.get(target, prop, receiver);\n      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {\n        return true;\n      }\n      removePropListener(prop);\n      if (isObject(value)) {\n        value = (0,proxy_compare__WEBPACK_IMPORTED_MODULE_0__.getUntracked)(value) || value;\n      }\n      let nextValue = value;\n      if (Object.getOwnPropertyDescriptor(target, prop)?.set) ; else {\n        if (!proxyStateMap.has(value) && canProxy(value)) {\n          nextValue = proxy(value);\n        }\n        const childProxyState = !refSet.has(nextValue) && proxyStateMap.get(nextValue);\n        if (childProxyState) {\n          addPropListener(prop, childProxyState);\n        }\n      }\n      Reflect.set(target, prop, nextValue, receiver);\n      notifyUpdate([\"set\", [prop], value, prevValue]);\n      return true;\n    }\n  };\n  const proxyObject = newProxy(baseObject, handler);\n  proxyCache.set(initialObject, proxyObject);\n  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];\n  proxyStateMap.set(proxyObject, proxyState);\n  Reflect.ownKeys(initialObject).forEach((key) => {\n    const desc = Object.getOwnPropertyDescriptor(initialObject, key);\n    if (desc.get || desc.set) {\n      Object.defineProperty(baseObject, key, desc);\n    } else {\n      proxyObject[key] = initialObject[key];\n    }\n  });\n  return proxyObject;\n}) => [\n  // public functions\n  proxyFunction2,\n  // shared state\n  proxyStateMap,\n  refSet,\n  // internal things\n  objectIs,\n  newProxy,\n  canProxy,\n  snapCache,\n  createSnapshot,\n  proxyCache,\n  versionHolder\n];\nvar [proxyFunction] = buildProxyFunction();\nfunction proxy(initialObject = {}) {\n  return proxyFunction(initialObject);\n}\nfunction subscribe(proxyObject, callback, notifyInSync) {\n  const proxyState = proxyStateMap.get(proxyObject);\n  if (isDev() && !proxyState) {\n    console.warn(\"Please use proxy object\");\n  }\n  let promise;\n  const ops = [];\n  const addListener = proxyState[3];\n  let isListenerActive = false;\n  const listener = (op) => {\n    ops.push(op);\n    if (notifyInSync) {\n      callback(ops.splice(0));\n      return;\n    }\n    if (!promise) {\n      promise = Promise.resolve().then(() => {\n        promise = void 0;\n        if (isListenerActive) {\n          callback(ops.splice(0));\n        }\n      });\n    }\n  };\n  const removeListener = addListener(listener);\n  isListenerActive = true;\n  return () => {\n    isListenerActive = false;\n    removeListener();\n  };\n}\nfunction snapshot(proxyObject) {\n  const proxyState = proxyStateMap.get(proxyObject);\n  if (isDev() && !proxyState) {\n    console.warn(\"Please use proxy object\");\n  }\n  const [target, ensureVersion, createSnapshot] = proxyState;\n  return createSnapshot(target, ensureVersion());\n}\nfunction ref(obj) {\n  refSet.add(obj);\n  return obj;\n}\n\n// src/proxy-computed.ts\nfunction proxyWithComputed(initialObject, computedFns) {\n  const keys = Object.keys(computedFns);\n  keys.forEach((key) => {\n    if (Object.getOwnPropertyDescriptor(initialObject, key)) {\n      throw new Error(\"object property already defined\");\n    }\n    const computedFn = computedFns[key];\n    const { get, set: set2 } = typeof computedFn === \"function\" ? { get: computedFn } : computedFn;\n    const desc = {};\n    desc.get = () => get(snapshot(proxyObject));\n    if (set2) {\n      desc.set = (newValue) => set2(proxyObject, newValue);\n    }\n    Object.defineProperty(initialObject, key, desc);\n  });\n  const proxyObject = proxy(initialObject);\n  return proxyObject;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHphZy1qcytzdG9yZUAxLjguMi9ub2RlX21vZHVsZXMvQHphZy1qcy9zdG9yZS9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUEwRDs7QUFFMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixhQUFvQjs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxpQkFBaUI7QUFDbEU7QUFDQTtBQUNBLHNEQUFzRCxpQkFBaUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLDBEQUFXO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDBEQUFXO0FBQ2pCO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMkRBQVk7QUFDNUI7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUJBQWlCLHVDQUF1QyxrQkFBa0I7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFZ0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcd2VzanJcXERvY3VtZW50c1xcUHJvamV0b3NcXGRhc2gtY3J5cHRvY29pblxcbm9kZV9tb2R1bGVzXFwucG5wbVxcQHphZy1qcytzdG9yZUAxLjguMlxcbm9kZV9tb2R1bGVzXFxAemFnLWpzXFxzdG9yZVxcZGlzdFxcaW5kZXgubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG1hcmtUb1RyYWNrLCBnZXRVbnRyYWNrZWQgfSBmcm9tICdwcm94eS1jb21wYXJlJztcblxuLy8gc3JjL2dsb2JhbC50c1xuZnVuY3Rpb24gZ2xvYigpIHtcbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gZ2xvYmFsVGhpcztcbiAgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gc2VsZjtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiB3aW5kb3c7XG4gIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gZ2xvYmFsO1xufVxuZnVuY3Rpb24gZ2xvYmFsUmVmKGtleSwgdmFsdWUpIHtcbiAgY29uc3QgZyA9IGdsb2IoKTtcbiAgaWYgKCFnKSByZXR1cm4gdmFsdWUoKTtcbiAgZ1trZXldIHx8IChnW2tleV0gPSB2YWx1ZSgpKTtcbiAgcmV0dXJuIGdba2V5XTtcbn1cbnZhciByZWZTZXQgPSBnbG9iYWxSZWYoXCJfX3phZ19fcmVmU2V0XCIsICgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpKTtcblxuLy8gc3JjL3V0aWxzLnRzXG52YXIgaXNSZWFjdEVsZW1lbnQgPSAoeCkgPT4gdHlwZW9mIHggPT09IFwib2JqZWN0XCIgJiYgeCAhPT0gbnVsbCAmJiBcIiQkdHlwZW9mXCIgaW4geCAmJiBcInByb3BzXCIgaW4geDtcbnZhciBpc1Z1ZUVsZW1lbnQgPSAoeCkgPT4gdHlwZW9mIHggPT09IFwib2JqZWN0XCIgJiYgeCAhPT0gbnVsbCAmJiBcIl9fdl9pc1ZOb2RlXCIgaW4geDtcbnZhciBpc0RPTUVsZW1lbnQgPSAoeCkgPT4gdHlwZW9mIHggPT09IFwib2JqZWN0XCIgJiYgeCAhPT0gbnVsbCAmJiBcIm5vZGVUeXBlXCIgaW4geCAmJiB0eXBlb2YgeC5ub2RlTmFtZSA9PT0gXCJzdHJpbmdcIjtcbnZhciBpc0VsZW1lbnQgPSAoeCkgPT4gaXNSZWFjdEVsZW1lbnQoeCkgfHwgaXNWdWVFbGVtZW50KHgpIHx8IGlzRE9NRWxlbWVudCh4KTtcbnZhciBpc09iamVjdCA9ICh4KSA9PiB4ICE9PSBudWxsICYmIHR5cGVvZiB4ID09PSBcIm9iamVjdFwiO1xudmFyIGNhblByb3h5ID0gKHgpID0+IGlzT2JqZWN0KHgpICYmICFyZWZTZXQuaGFzKHgpICYmIChBcnJheS5pc0FycmF5KHgpIHx8ICEoU3ltYm9sLml0ZXJhdG9yIGluIHgpKSAmJiAhaXNFbGVtZW50KHgpICYmICEoeCBpbnN0YW5jZW9mIFdlYWtNYXApICYmICEoeCBpbnN0YW5jZW9mIFdlYWtTZXQpICYmICEoeCBpbnN0YW5jZW9mIEVycm9yKSAmJiAhKHggaW5zdGFuY2VvZiBOdW1iZXIpICYmICEoeCBpbnN0YW5jZW9mIERhdGUpICYmICEoeCBpbnN0YW5jZW9mIFN0cmluZykgJiYgISh4IGluc3RhbmNlb2YgUmVnRXhwKSAmJiAhKHggaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgJiYgISh4IGluc3RhbmNlb2YgUHJvbWlzZSk7XG52YXIgaXNEZXYgPSAoKSA9PiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCI7XG5cbi8vIHNyYy9jbG9uZS50c1xuZnVuY3Rpb24gc2V0KG9iaiwga2V5LCB2YWwpIHtcbiAgaWYgKHR5cGVvZiB2YWwudmFsdWUgPT09IFwib2JqZWN0XCIgJiYgIWNhblByb3h5KHZhbC52YWx1ZSkpIHZhbC52YWx1ZSA9IGNsb25lKHZhbC52YWx1ZSk7XG4gIGlmICghdmFsLmVudW1lcmFibGUgfHwgdmFsLmdldCB8fCB2YWwuc2V0IHx8ICF2YWwuY29uZmlndXJhYmxlIHx8ICF2YWwud3JpdGFibGUgfHwga2V5ID09PSBcIl9fcHJvdG9fX1wiKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWwpO1xuICB9IGVsc2Ugb2JqW2tleV0gPSB2YWwudmFsdWU7XG59XG5mdW5jdGlvbiBjbG9uZSh4KSB7XG4gIGlmICh0eXBlb2YgeCAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHg7XG4gIHZhciBpID0gMCwgaywgbGlzdCwgdG1wLCBzdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCk7XG4gIGlmIChzdHIgPT09IFwiW29iamVjdCBPYmplY3RdXCIpIHtcbiAgICB0bXAgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih4KSB8fCBudWxsKTtcbiAgfSBlbHNlIGlmIChzdHIgPT09IFwiW29iamVjdCBBcnJheV1cIikge1xuICAgIHRtcCA9IEFycmF5KHgubGVuZ3RoKTtcbiAgfSBlbHNlIGlmIChzdHIgPT09IFwiW29iamVjdCBTZXRdXCIpIHtcbiAgICB0bXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHguZm9yRWFjaChmdW5jdGlvbih2YWwpIHtcbiAgICAgIHRtcC5hZGQoY2xvbmUodmFsKSk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoc3RyID09PSBcIltvYmplY3QgTWFwXVwiKSB7XG4gICAgdG1wID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB4LmZvckVhY2goZnVuY3Rpb24odmFsLCBrZXkpIHtcbiAgICAgIHRtcC5zZXQoY2xvbmUoa2V5KSwgY2xvbmUodmFsKSk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoc3RyID09PSBcIltvYmplY3QgRGF0ZV1cIikge1xuICAgIHRtcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgreCk7XG4gIH0gZWxzZSBpZiAoc3RyID09PSBcIltvYmplY3QgUmVnRXhwXVwiKSB7XG4gICAgdG1wID0gbmV3IFJlZ0V4cCh4LnNvdXJjZSwgeC5mbGFncyk7XG4gIH0gZWxzZSBpZiAoc3RyID09PSBcIltvYmplY3QgRGF0YVZpZXddXCIpIHtcbiAgICB0bXAgPSBuZXcgeC5jb25zdHJ1Y3RvcihjbG9uZSh4LmJ1ZmZlcikpO1xuICB9IGVsc2UgaWYgKHN0ciA9PT0gXCJbb2JqZWN0IEFycmF5QnVmZmVyXVwiKSB7XG4gICAgdG1wID0geC5zbGljZSgwKTtcbiAgfSBlbHNlIGlmIChzdHIgPT09IFwiW29iamVjdCBCbG9iXVwiKSB7XG4gICAgdG1wID0geC5zbGljZSgpO1xuICB9IGVsc2UgaWYgKHN0ci5zbGljZSgtNikgPT09IFwiQXJyYXldXCIpIHtcbiAgICB0bXAgPSBuZXcgeC5jb25zdHJ1Y3Rvcih4KTtcbiAgfVxuICBpZiAodG1wKSB7XG4gICAgZm9yIChsaXN0ID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh4KTsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHNldCh0bXAsIGxpc3RbaV0sIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoeCwgbGlzdFtpXSkpO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwLCBsaXN0ID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoeCk7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwodG1wLCBrID0gbGlzdFtpXSkgJiYgdG1wW2tdID09PSB4W2tdKSBjb250aW51ZTtcbiAgICAgIHNldCh0bXAsIGssIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoeCwgaykpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG1wIHx8IHg7XG59XG52YXIgcHJveHlTdGF0ZU1hcCA9IGdsb2JhbFJlZihcIl9femFnX19wcm94eVN0YXRlTWFwXCIsICgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpKTtcbnZhciBidWlsZFByb3h5RnVuY3Rpb24gPSAob2JqZWN0SXMgPSBPYmplY3QuaXMsIG5ld1Byb3h5ID0gKHRhcmdldCwgaGFuZGxlcikgPT4gbmV3IFByb3h5KHRhcmdldCwgaGFuZGxlciksIHNuYXBDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBjcmVhdGVTbmFwc2hvdCA9ICh0YXJnZXQsIHZlcnNpb24pID0+IHtcbiAgY29uc3QgY2FjaGUgPSBzbmFwQ2FjaGUuZ2V0KHRhcmdldCk7XG4gIGlmIChjYWNoZT8uWzBdID09PSB2ZXJzaW9uKSB7XG4gICAgcmV0dXJuIGNhY2hlWzFdO1xuICB9XG4gIGNvbnN0IHNuYXAgPSBBcnJheS5pc0FycmF5KHRhcmdldCkgPyBbXSA6IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldCkpO1xuICBtYXJrVG9UcmFjayhzbmFwLCB0cnVlKTtcbiAgc25hcENhY2hlLnNldCh0YXJnZXQsIFt2ZXJzaW9uLCBzbmFwXSk7XG4gIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gUmVmbGVjdC5nZXQodGFyZ2V0LCBrZXkpO1xuICAgIGlmIChyZWZTZXQuaGFzKHZhbHVlKSkge1xuICAgICAgbWFya1RvVHJhY2sodmFsdWUsIGZhbHNlKTtcbiAgICAgIHNuYXBba2V5XSA9IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAocHJveHlTdGF0ZU1hcC5oYXModmFsdWUpKSB7XG4gICAgICBzbmFwW2tleV0gPSBzbmFwc2hvdCh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNuYXBba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHNuYXApO1xufSwgcHJveHlDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCB2ZXJzaW9uSG9sZGVyID0gWzEsIDFdLCBwcm94eUZ1bmN0aW9uMiA9IChpbml0aWFsT2JqZWN0KSA9PiB7XG4gIGlmICghaXNPYmplY3QoaW5pdGlhbE9iamVjdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJvYmplY3QgcmVxdWlyZWRcIik7XG4gIH1cbiAgY29uc3QgZm91bmQgPSBwcm94eUNhY2hlLmdldChpbml0aWFsT2JqZWN0KTtcbiAgaWYgKGZvdW5kKSB7XG4gICAgcmV0dXJuIGZvdW5kO1xuICB9XG4gIGxldCB2ZXJzaW9uID0gdmVyc2lvbkhvbGRlclswXTtcbiAgY29uc3QgbGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3Qgbm90aWZ5VXBkYXRlID0gKG9wLCBuZXh0VmVyc2lvbiA9ICsrdmVyc2lvbkhvbGRlclswXSkgPT4ge1xuICAgIGlmICh2ZXJzaW9uICE9PSBuZXh0VmVyc2lvbikge1xuICAgICAgdmVyc2lvbiA9IG5leHRWZXJzaW9uO1xuICAgICAgbGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiBsaXN0ZW5lcihvcCwgbmV4dFZlcnNpb24pKTtcbiAgICB9XG4gIH07XG4gIGxldCBjaGVja1ZlcnNpb24gPSB2ZXJzaW9uSG9sZGVyWzFdO1xuICBjb25zdCBlbnN1cmVWZXJzaW9uID0gKG5leHRDaGVja1ZlcnNpb24gPSArK3ZlcnNpb25Ib2xkZXJbMV0pID0+IHtcbiAgICBpZiAoY2hlY2tWZXJzaW9uICE9PSBuZXh0Q2hlY2tWZXJzaW9uICYmICFsaXN0ZW5lcnMuc2l6ZSkge1xuICAgICAgY2hlY2tWZXJzaW9uID0gbmV4dENoZWNrVmVyc2lvbjtcbiAgICAgIHByb3BQcm94eVN0YXRlcy5mb3JFYWNoKChbcHJvcFByb3h5U3RhdGVdKSA9PiB7XG4gICAgICAgIGNvbnN0IHByb3BWZXJzaW9uID0gcHJvcFByb3h5U3RhdGVbMV0obmV4dENoZWNrVmVyc2lvbik7XG4gICAgICAgIGlmIChwcm9wVmVyc2lvbiA+IHZlcnNpb24pIHtcbiAgICAgICAgICB2ZXJzaW9uID0gcHJvcFZlcnNpb247XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdmVyc2lvbjtcbiAgfTtcbiAgY29uc3QgY3JlYXRlUHJvcExpc3RlbmVyID0gKHByb3ApID0+IChvcCwgbmV4dFZlcnNpb24pID0+IHtcbiAgICBjb25zdCBuZXdPcCA9IFsuLi5vcF07XG4gICAgbmV3T3BbMV0gPSBbcHJvcCwgLi4ubmV3T3BbMV1dO1xuICAgIG5vdGlmeVVwZGF0ZShuZXdPcCwgbmV4dFZlcnNpb24pO1xuICB9O1xuICBjb25zdCBwcm9wUHJveHlTdGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCBhZGRQcm9wTGlzdGVuZXIgPSAocHJvcCwgcHJvcFByb3h5U3RhdGUpID0+IHtcbiAgICBpZiAoaXNEZXYoKSAmJiBwcm9wUHJveHlTdGF0ZXMuaGFzKHByb3ApKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwcm9wIGxpc3RlbmVyIGFscmVhZHkgZXhpc3RzXCIpO1xuICAgIH1cbiAgICBpZiAobGlzdGVuZXJzLnNpemUpIHtcbiAgICAgIGNvbnN0IHJlbW92ZSA9IHByb3BQcm94eVN0YXRlWzNdKGNyZWF0ZVByb3BMaXN0ZW5lcihwcm9wKSk7XG4gICAgICBwcm9wUHJveHlTdGF0ZXMuc2V0KHByb3AsIFtwcm9wUHJveHlTdGF0ZSwgcmVtb3ZlXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb3BQcm94eVN0YXRlcy5zZXQocHJvcCwgW3Byb3BQcm94eVN0YXRlXSk7XG4gICAgfVxuICB9O1xuICBjb25zdCByZW1vdmVQcm9wTGlzdGVuZXIgPSAocHJvcCkgPT4ge1xuICAgIGNvbnN0IGVudHJ5ID0gcHJvcFByb3h5U3RhdGVzLmdldChwcm9wKTtcbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIHByb3BQcm94eVN0YXRlcy5kZWxldGUocHJvcCk7XG4gICAgICBlbnRyeVsxXT8uKCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBhZGRMaXN0ZW5lciA9IChsaXN0ZW5lcikgPT4ge1xuICAgIGxpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xuICAgIGlmIChsaXN0ZW5lcnMuc2l6ZSA9PT0gMSkge1xuICAgICAgcHJvcFByb3h5U3RhdGVzLmZvckVhY2goKFtwcm9wUHJveHlTdGF0ZSwgcHJldlJlbW92ZV0sIHByb3ApID0+IHtcbiAgICAgICAgaWYgKGlzRGV2KCkgJiYgcHJldlJlbW92ZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInJlbW92ZSBhbHJlYWR5IGV4aXN0c1wiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZW1vdmUgPSBwcm9wUHJveHlTdGF0ZVszXShjcmVhdGVQcm9wTGlzdGVuZXIocHJvcCkpO1xuICAgICAgICBwcm9wUHJveHlTdGF0ZXMuc2V0KHByb3AsIFtwcm9wUHJveHlTdGF0ZSwgcmVtb3ZlXSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgcmVtb3ZlTGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICBsaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICAgIGlmIChsaXN0ZW5lcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICBwcm9wUHJveHlTdGF0ZXMuZm9yRWFjaCgoW3Byb3BQcm94eVN0YXRlLCByZW1vdmVdLCBwcm9wKSA9PiB7XG4gICAgICAgICAgaWYgKHJlbW92ZSkge1xuICAgICAgICAgICAgcmVtb3ZlKCk7XG4gICAgICAgICAgICBwcm9wUHJveHlTdGF0ZXMuc2V0KHByb3AsIFtwcm9wUHJveHlTdGF0ZV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gcmVtb3ZlTGlzdGVuZXI7XG4gIH07XG4gIGNvbnN0IGJhc2VPYmplY3QgPSBBcnJheS5pc0FycmF5KGluaXRpYWxPYmplY3QpID8gW10gOiBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihpbml0aWFsT2JqZWN0KSk7XG4gIGNvbnN0IGhhbmRsZXIgPSB7XG4gICAgZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wKSB7XG4gICAgICBjb25zdCBwcmV2VmFsdWUgPSBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3ApO1xuICAgICAgcmVtb3ZlUHJvcExpc3RlbmVyKHByb3ApO1xuICAgICAgY29uc3QgZGVsZXRlZCA9IFJlZmxlY3QuZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wKTtcbiAgICAgIGlmIChkZWxldGVkKSB7XG4gICAgICAgIG5vdGlmeVVwZGF0ZShbXCJkZWxldGVcIiwgW3Byb3BdLCBwcmV2VmFsdWVdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWxldGVkO1xuICAgIH0sXG4gICAgc2V0KHRhcmdldCwgcHJvcCwgdmFsdWUsIHJlY2VpdmVyKSB7XG4gICAgICBjb25zdCBoYXNQcmV2VmFsdWUgPSBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3ApO1xuICAgICAgY29uc3QgcHJldlZhbHVlID0gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICBpZiAoaGFzUHJldlZhbHVlICYmIChvYmplY3RJcyhwcmV2VmFsdWUsIHZhbHVlKSB8fCBwcm94eUNhY2hlLmhhcyh2YWx1ZSkgJiYgb2JqZWN0SXMocHJldlZhbHVlLCBwcm94eUNhY2hlLmdldCh2YWx1ZSkpKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJlbW92ZVByb3BMaXN0ZW5lcihwcm9wKTtcbiAgICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSBnZXRVbnRyYWNrZWQodmFsdWUpIHx8IHZhbHVlO1xuICAgICAgfVxuICAgICAgbGV0IG5leHRWYWx1ZSA9IHZhbHVlO1xuICAgICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wKT8uc2V0KSA7IGVsc2Uge1xuICAgICAgICBpZiAoIXByb3h5U3RhdGVNYXAuaGFzKHZhbHVlKSAmJiBjYW5Qcm94eSh2YWx1ZSkpIHtcbiAgICAgICAgICBuZXh0VmFsdWUgPSBwcm94eSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hpbGRQcm94eVN0YXRlID0gIXJlZlNldC5oYXMobmV4dFZhbHVlKSAmJiBwcm94eVN0YXRlTWFwLmdldChuZXh0VmFsdWUpO1xuICAgICAgICBpZiAoY2hpbGRQcm94eVN0YXRlKSB7XG4gICAgICAgICAgYWRkUHJvcExpc3RlbmVyKHByb3AsIGNoaWxkUHJveHlTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFJlZmxlY3Quc2V0KHRhcmdldCwgcHJvcCwgbmV4dFZhbHVlLCByZWNlaXZlcik7XG4gICAgICBub3RpZnlVcGRhdGUoW1wic2V0XCIsIFtwcm9wXSwgdmFsdWUsIHByZXZWYWx1ZV0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9O1xuICBjb25zdCBwcm94eU9iamVjdCA9IG5ld1Byb3h5KGJhc2VPYmplY3QsIGhhbmRsZXIpO1xuICBwcm94eUNhY2hlLnNldChpbml0aWFsT2JqZWN0LCBwcm94eU9iamVjdCk7XG4gIGNvbnN0IHByb3h5U3RhdGUgPSBbYmFzZU9iamVjdCwgZW5zdXJlVmVyc2lvbiwgY3JlYXRlU25hcHNob3QsIGFkZExpc3RlbmVyXTtcbiAgcHJveHlTdGF0ZU1hcC5zZXQocHJveHlPYmplY3QsIHByb3h5U3RhdGUpO1xuICBSZWZsZWN0Lm93bktleXMoaW5pdGlhbE9iamVjdCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgY29uc3QgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaW5pdGlhbE9iamVjdCwga2V5KTtcbiAgICBpZiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiYXNlT2JqZWN0LCBrZXksIGRlc2MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm94eU9iamVjdFtrZXldID0gaW5pdGlhbE9iamVjdFtrZXldO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBwcm94eU9iamVjdDtcbn0pID0+IFtcbiAgLy8gcHVibGljIGZ1bmN0aW9uc1xuICBwcm94eUZ1bmN0aW9uMixcbiAgLy8gc2hhcmVkIHN0YXRlXG4gIHByb3h5U3RhdGVNYXAsXG4gIHJlZlNldCxcbiAgLy8gaW50ZXJuYWwgdGhpbmdzXG4gIG9iamVjdElzLFxuICBuZXdQcm94eSxcbiAgY2FuUHJveHksXG4gIHNuYXBDYWNoZSxcbiAgY3JlYXRlU25hcHNob3QsXG4gIHByb3h5Q2FjaGUsXG4gIHZlcnNpb25Ib2xkZXJcbl07XG52YXIgW3Byb3h5RnVuY3Rpb25dID0gYnVpbGRQcm94eUZ1bmN0aW9uKCk7XG5mdW5jdGlvbiBwcm94eShpbml0aWFsT2JqZWN0ID0ge30pIHtcbiAgcmV0dXJuIHByb3h5RnVuY3Rpb24oaW5pdGlhbE9iamVjdCk7XG59XG5mdW5jdGlvbiBzdWJzY3JpYmUocHJveHlPYmplY3QsIGNhbGxiYWNrLCBub3RpZnlJblN5bmMpIHtcbiAgY29uc3QgcHJveHlTdGF0ZSA9IHByb3h5U3RhdGVNYXAuZ2V0KHByb3h5T2JqZWN0KTtcbiAgaWYgKGlzRGV2KCkgJiYgIXByb3h5U3RhdGUpIHtcbiAgICBjb25zb2xlLndhcm4oXCJQbGVhc2UgdXNlIHByb3h5IG9iamVjdFwiKTtcbiAgfVxuICBsZXQgcHJvbWlzZTtcbiAgY29uc3Qgb3BzID0gW107XG4gIGNvbnN0IGFkZExpc3RlbmVyID0gcHJveHlTdGF0ZVszXTtcbiAgbGV0IGlzTGlzdGVuZXJBY3RpdmUgPSBmYWxzZTtcbiAgY29uc3QgbGlzdGVuZXIgPSAob3ApID0+IHtcbiAgICBvcHMucHVzaChvcCk7XG4gICAgaWYgKG5vdGlmeUluU3luYykge1xuICAgICAgY2FsbGJhY2sob3BzLnNwbGljZSgwKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghcHJvbWlzZSkge1xuICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICBwcm9taXNlID0gdm9pZCAwO1xuICAgICAgICBpZiAoaXNMaXN0ZW5lckFjdGl2ZSkge1xuICAgICAgICAgIGNhbGxiYWNrKG9wcy5zcGxpY2UoMCkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHJlbW92ZUxpc3RlbmVyID0gYWRkTGlzdGVuZXIobGlzdGVuZXIpO1xuICBpc0xpc3RlbmVyQWN0aXZlID0gdHJ1ZTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBpc0xpc3RlbmVyQWN0aXZlID0gZmFsc2U7XG4gICAgcmVtb3ZlTGlzdGVuZXIoKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHNuYXBzaG90KHByb3h5T2JqZWN0KSB7XG4gIGNvbnN0IHByb3h5U3RhdGUgPSBwcm94eVN0YXRlTWFwLmdldChwcm94eU9iamVjdCk7XG4gIGlmIChpc0RldigpICYmICFwcm94eVN0YXRlKSB7XG4gICAgY29uc29sZS53YXJuKFwiUGxlYXNlIHVzZSBwcm94eSBvYmplY3RcIik7XG4gIH1cbiAgY29uc3QgW3RhcmdldCwgZW5zdXJlVmVyc2lvbiwgY3JlYXRlU25hcHNob3RdID0gcHJveHlTdGF0ZTtcbiAgcmV0dXJuIGNyZWF0ZVNuYXBzaG90KHRhcmdldCwgZW5zdXJlVmVyc2lvbigpKTtcbn1cbmZ1bmN0aW9uIHJlZihvYmopIHtcbiAgcmVmU2V0LmFkZChvYmopO1xuICByZXR1cm4gb2JqO1xufVxuXG4vLyBzcmMvcHJveHktY29tcHV0ZWQudHNcbmZ1bmN0aW9uIHByb3h5V2l0aENvbXB1dGVkKGluaXRpYWxPYmplY3QsIGNvbXB1dGVkRm5zKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhjb21wdXRlZEZucyk7XG4gIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaW5pdGlhbE9iamVjdCwga2V5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwib2JqZWN0IHByb3BlcnR5IGFscmVhZHkgZGVmaW5lZFwiKTtcbiAgICB9XG4gICAgY29uc3QgY29tcHV0ZWRGbiA9IGNvbXB1dGVkRm5zW2tleV07XG4gICAgY29uc3QgeyBnZXQsIHNldDogc2V0MiB9ID0gdHlwZW9mIGNvbXB1dGVkRm4gPT09IFwiZnVuY3Rpb25cIiA/IHsgZ2V0OiBjb21wdXRlZEZuIH0gOiBjb21wdXRlZEZuO1xuICAgIGNvbnN0IGRlc2MgPSB7fTtcbiAgICBkZXNjLmdldCA9ICgpID0+IGdldChzbmFwc2hvdChwcm94eU9iamVjdCkpO1xuICAgIGlmIChzZXQyKSB7XG4gICAgICBkZXNjLnNldCA9IChuZXdWYWx1ZSkgPT4gc2V0Mihwcm94eU9iamVjdCwgbmV3VmFsdWUpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaW5pdGlhbE9iamVjdCwga2V5LCBkZXNjKTtcbiAgfSk7XG4gIGNvbnN0IHByb3h5T2JqZWN0ID0gcHJveHkoaW5pdGlhbE9iamVjdCk7XG4gIHJldHVybiBwcm94eU9iamVjdDtcbn1cblxuZXhwb3J0IHsgY2xvbmUsIGdsb2JhbFJlZiwgcHJveHksIHByb3h5V2l0aENvbXB1dGVkLCByZWYsIHNuYXBzaG90LCBzdWJzY3JpYmUgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@zag-js+store@1.8.2/node_modules/@zag-js/store/dist/index.mjs\n");

/***/ })

};
;